function CalcParamNum(s)
    if string.match(s, "^[%s]*$") then
        return 0
    end
    local b1 = 0
    local b2 = 0
    local ret = 1
    for i = 1, #s do
        local c = string.byte(s, i)
        if b1 == 0 and b2 == 0 and c == 44 then
            ret = ret + 1
        elseif c == 40 then
            b1 = b1 + 1
        elseif c == 41 then
            b1 = b1 - 1
        elseif c == 123 then
            b2 = b2 + 1
        elseif c == 125 then
            b2 = b2 - 1
        end
    end
    return ret
end
function toboolean(v)
    if type(v) == "string" then
        if v == "false" or v == "nil" or string.match(v, "^[%s]*$") then
            return false
        else
            return true
        end
    else
        return not (not (v))
    end
end
local function CheckName(s)
    if string.match(s, "^[%w_][%w_ ]*$") == nil then
        return "must be a string of letters, digits, spaces, and underscores, not beginning with a space"
    end
end
local function CheckVName(s)
    if string.match(s, "^[%a_][%w_]*$") == nil then
        return "must be a string of letters, digits, and underscores, not beginning with a digit"
    end
end
local function CheckExpr(s)
    if string.match(s, "^[%s]*$") then
        return "can not be omitted"
    end
    local _, msg = loadstring("return " .. s)
    if msg ~= nil then
        return msg
    end
end
local function CheckPos(s)
    if string.match(s, "^[%s]*$") then
        return "can not be omitted"
    end
    local _, msg = loadstring("return " .. s)
    if msg ~= nil then
        return msg
    end
    if CalcParamNum(s) ~= 2 then
        return "invalid expression of position"
    end
end
local function CheckExprOmit(s)
    local _, msg = loadstring("return " .. s)
    if msg ~= nil then
        return msg
    end
end
local function CheckCode(s)
    local _, msg = loadstring(s)
    if msg ~= nil then
        return msg
    end
end
local function CheckParam(s)
    local _, msg = loadstring("return function(" .. s .. ") end")
    if msg ~= nil then
        return msg
    end
end
local function CheckNonBlank(s)
    if string.match(s, "^[%s]*$") then
        return "can not be blank"
    end
end
local function CheckClassName(s)
    if string.match(s, "^[%s]*$") then
        return "can not be blank"
    else
        if checkClassName[s] then
            return string.format("repeated type name %q", s)
        else
            checkClassName[s] = true
        end
    end
end
local function IsBlank(s)
    if string.match(s, "^[%s]*$") then
        return true
    else
        return false
    end
end
local function CheckResFileInPack(name)
    if checkResFile[name] == nil then
        checkResFile[name] = true
        return true
    else
        return false
    end
end
local function CheckAnonymous(name, fullname)
    if checkResFile[name] == nil then
        checkResFile[name] = true
        checkAnonymous[name] = fullname
        return true
    else
        if checkAnonymous[name] == fullname then
            return true
        else
            return false
        end
    end
end
local function CheckAddRes(absfn, name)
    local f, msg = io.open("editor\\tmp\\_pack_res.bat", "a")
    if msg then
        return msg
    end
    f:write(string.format('..\\tools\\7z\\7z u -tzip -mcu=on "..\\game\\mod\\%s.zip" "%s"\n', outputName, absfn))
    f:close()
    if name ~= nil then
        f, msg = io.open("editor\\tmp\\_pack_lib.bat", "a")
        if msg then
            return msg
        end
        f:write(string.format('copy "%s" "..\\libs\\%s\\%s" \n', absfn, outputName, name))
        f:close()
    end
end

className = nil
difficulty = nil
projectmode = nil

parimg = {}
for i = 1, 16 do
    parimg['parimg' .. i] = true
end
event_type_dict = { frame = true, render = true, colli = true, kill = true, del = true }

nodeType = {
    ['setting'] = {
        { 'Output name', 'any', CheckName },
        { 'Author', 'any', CheckName },
        { 'Allow practice', 'bool', CheckExpr },
        { 'Allow sc practice', 'bool', CheckExpr },
        { 'Mode', 'projectmode' },
        disptype = 'project settings',
        totext = function()
            return 'project settings'
        end,
        allowparent = {},
        allowchild = {},
        forbiddelete = true,
        check = function(nodedata)
            local attr = nodedata.attr
            if attr[5] == 'lib' then
                projectmode = 'lib'
            else
                projectmode = 'game'
            end
        end,
        tohead = function(nodedata)
            return string.format("-- Generated by LuaSTG editor\n-- Mod name: %s\n_author=%q\n_mod_version=%d\n_allow_practice=%s\n_allow_sc_practice=%s\n\n",
                    nodedata.attr[1], nodedata.attr[2], _luastg_version, nodedata.attr[3], nodedata.attr[4])
        end,
    },
    folder = {
        { 'Title', 'any' },
        allowparent = { 'root', 'folder' },
        depth = 0,
        totext = function(nodedata)
            return nodedata.attr[1]
        end,
    },
    -- language
    patch = {
        { 'path', 'resfile', CheckNonBlank },
        editfirst = true,
        allowparent = { 'root', 'folder' },
        allowchild = {},
        totext = function(nodedata)
            return string.format("patch %q", wx.wxFileName(nodedata.attr[1]):GetName())
        end,
        tohead = function(nodedata)
            return string.format("Include%q\n", wx.wxFileName(nodedata.attr[1]):GetFullName())
        end,
        check = function(nodedata)
            local absfn = MakeFullPath(nodedata.attr[1])
            if not wx.wxFileName(absfn):FileExists() then
                return string.format("Resource file %q does not exist", absfn)
            end
            local fn = wx.wxFileName(nodedata.attr[1]):GetFullName()
            if not CheckResFileInPack(fn) then
                return string.format("Repeated resource file name %q", fn)
            end
            local f, msg = io.open("editor\\tmp\\_pack_res.bat", "a")
            if msg then
                return msg
            end
            f:write(string.format('..\\tools\\7z\\7z u -tzip -mcu=on "..\\game\\mod\\%s.zip" "%s"\n', outputName, absfn))
            f:write(string.format('cd /D "%s" \n', wx.wxFileName(absfn):GetPath(wx.wxPATH_GET_VOLUME)))
            f:write(string.format('"%s\\..\\tools\\7z\\7z" u -tzip -mcu=on "%s\\mod\\%s.zip" THlib\n', cwd, cwd, outputName))
            f:write(string.format('cd /D "%s" \n', cwd))
            f:close()
        end
    },
    codeblock = {
        { 'Title', 'any' },
        disptype = 'code block',
        forbidparent = { 'root', 'folder' },
        totext = function(nodedata)
            return nodedata.attr[1]
        end,
        tohead = function()
            return "do\n"
        end,
        tofoot = function()
            return "end\n"
        end,
    },
    code = {
        { 'Code', 'any', CheckCode },
        allowchild = {},
        editfirst = true,
        totext = function(nodedata)
            local start, finish = string.find(nodedata.attr[1], '^.-\n')
            if start == nil then
                return nodedata.attr[1]
            else
                return string.sub(nodedata.attr[1], 1, finish - 1) .. ' ...'
            end
        end,
        tohead = function(nodedata)
            return nodedata.attr[1] .. "\n"
        end,
    },
    comment = {
        { 'Comment', 'any' },
        { 'Remove Comment', 'bool', CheckExpr },
        default = { ["type"] = 'comment', attr = { '', 'false' } },
        --allowchild={},
        editfirst = true,
        totext = function(nodedata)
            if nodedata.attr[2] == 'true' then
                return nodedata.attr[1]
            else
                return "[comment] " .. nodedata.attr[1]
            end
        end,
        tohead = function(nodedata)
            if nodedata.attr[2] == 'true' then
                return "--[[ " .. nodedata.attr[1] .. " --]]\n"
            else
                comment_n = comment_n + 1
                return "--[[ " .. nodedata.attr[1] .. " --]]--[" .. string.rep("=", comment_n) .. "[\n"
            end
        end,
        tofoot = function(nodedata)
            if nodedata.attr[2] == 'true' then
                return ""
            else
                comment_n = comment_n - 1
                return "--]" .. string.rep("=", comment_n + 1) .. "]\n"
            end
        end,
        tocolor = function(nodedata)
            if nodedata.attr[2] == 'true' then
                return { 0, 0, 0, 0, 1 }
            else
                return { 128, 128, 128, 255 }
            end
            return { 128, 128, 128, 255 }
        end,
    },
    variable = {
        { 'Name', 'any', CheckVName },
        { 'Initial value', 'any', CheckExprOmit },
        disptype = 'define variable',
        editfirst = true,
        allowchild = {},
        forbidparent = { 'root', 'folder' },
        totext = function(nodedata)
            if IsBlank(nodedata.attr[2]) then
                return 'define local variable ' .. nodedata.attr[1]
            else
                return 'define local variable ' .. nodedata.attr[1] .. " = " .. nodedata.attr[2]
            end
        end,
        tohead = function(nodedata)
            if IsBlank(nodedata.attr[2]) then
                return 'local ' .. nodedata.attr[1] .. "\n"
            else
                return 'local ' .. nodedata.attr[1] .. " = " .. nodedata.attr[2] .. "\n"
            end
        end,
    },
    listcreate = {
        { 'Name', 'any', CheckVName },
        { 'Initial value', 'any', CheckExprOmit },
        disptype = 'define list',
        editfirst = true,
        allowchild = {},
        forbidparent = { 'root', 'folder' },
        totext = function(nodedata)
            if IsBlank(nodedata.attr[2]) then
                return 'define local list (' .. nodedata.attr[1] .. ')'
            else
                return 'define local list (' .. nodedata.attr[1] .. ") = " .. nodedata.attr[2]
            end
        end,
        tohead = function(nodedata)
            if IsBlank(nodedata.attr[2]) then
                return 'local ' .. nodedata.attr[1] .. "={}\n"
            else
                return 'local ' .. nodedata.attr[1] .. " = " .. nodedata.attr[2] .. "\n"
            end
        end,
    },
    listadd = {
        { 'List', 'any', CheckExpr },
        { 'Unit', 'any', CheckExpr },
        disptype = 'add unit to list',
        forbidparent = { 'folder', 'root' },
        editfirst = true,
        allowchild = {},
        default = { ['type'] = 'listadd', attr = { '', 'last' } },
        totext = function(nodedata)
            return string.format("Add %s to list (%s)", nodedata.attr[2], nodedata.attr[1])
        end,
        tohead = function(nodedata)
            return string.format("ex.UnitListAppend(%s,%s)\n", nodedata.attr[1], nodedata.attr[2])
        end,
    },
    ['listforeach'] = {
        { 'List', 'any', CheckExpr },
        { 'Var 1 name', 'any' },
        { 'Var 1 init value', 'any' },
        { 'Var 1 increment', 'any' },
        { 'Var 2 name', 'any' },
        { 'Var 2 init value', 'any' },
        { 'Var 2 increment', 'any' },
        { 'Var 3 name', 'any' },
        { 'Var 3 init value', 'any' },
        { 'Var 3 increment', 'any' },
        { 'Var 4 name', 'any' },
        { 'Var 4 init value', 'any' },
        { 'Var 4 increment', 'any' },
        default = { ["type"] = 'listforeach', attr = { 'last', '', '', '', '', '', '', '', '', '', '', '', '' } },
        forbidparent = { 'root', 'folder' },
        check = function(nodedata)
            local attr = nodedata.attr
            for i = 2, 11, 3 do
                if not IsBlank(attr[i]) then
                    local msg = CheckVName(attr[i])
                    if msg then
                        return string.format("Attribution '%s' is invalid: %s", nodeType["repeat"][i][1], msg)
                    end
                    msg = CheckExpr(attr[i + 1])
                    if msg then
                        return string.format("Attribution '%s' is invalid: %s", nodeType["repeat"][i + 1][1], msg)
                    end
                    msg = CheckExpr(attr[i + 2])
                    if msg then
                        return string.format("Attribution '%s' is invalid: %s", nodeType["repeat"][i + 2][1], msg)
                    end
                end
            end
        end,
        totext = function(nodedata)
            local ret = "for each unit in list ( " .. nodedata.attr[1] .. " ) "
            local attr = nodedata.attr
            for i = 2, 11, 3 do
                if not IsBlank(attr[i]) then
                    ret = ret .. " (" .. attr[i] .. "=" .. attr[i + 1] .. ",increment " .. attr[i + 2] .. ")"
                end
            end
            return ret
        end,
        tohead = function(nodedata)
            local ret = "do "
            local attr = nodedata.attr
            for i = 2, 11, 3 do
                if not IsBlank(attr[i]) then
                    ret = ret .. string.format("local %s,%s=(%s),(%s) ", attr[i], "_d_" .. attr[i], attr[i + 1], attr[i + 2])
                end
            end
            return ret .. "for _=1,#" .. nodedata.attr[1] .. " do\nunit=" .. nodedata.attr[1] .. "[_]\n"
        end,
        tofoot = function(nodedata)
            local ret = ""
            local attr = nodedata.attr
            for i = 2, 11, 3 do
                if not IsBlank(attr[i]) then
                    ret = ret .. string.format("%s=%s+%s ", attr[i], attr[i], "_d_" .. attr[i])
                end
            end
            return ret .. "end end\n"
        end,
    },
    ['repeat'] = {
        { 'Number of times', 'any', CheckExpr },
        { 'Var 1 name', 'any' },
        { 'Var 1 init value', 'any' },
        { 'Var 1 increment', 'any' },
        { 'Var 2 name', 'any' },
        { 'Var 2 init value', 'any' },
        { 'Var 2 increment', 'any' },
        { 'Var 3 name', 'any' },
        { 'Var 3 init value', 'any' },
        { 'Var 3 increment', 'any' },
        { 'Var 4 name', 'any' },
        { 'Var 4 init value', 'any' },
        { 'Var 4 increment', 'any' },
        default = { ["type"] = 'repeat', attr = { '_infinite', '', '', '', '', '', '', '', '', '', '', '', '' } },
        forbidparent = { 'root', 'folder' },
        check = function(nodedata)
            local attr = nodedata.attr
            for i = 2, 11, 3 do
                if not IsBlank(attr[i]) then
                    local msg = CheckVName(attr[i])
                    if msg then
                        return string.format("Attribution '%s' is invalid: %s", nodeType["repeat"][i][1], msg)
                    end
                    msg = CheckExpr(attr[i + 1])
                    if msg then
                        return string.format("Attribution '%s' is invalid: %s", nodeType["repeat"][i + 1][1], msg)
                    end
                    msg = CheckExpr(attr[i + 2])
                    if msg then
                        return string.format("Attribution '%s' is invalid: %s", nodeType["repeat"][i + 2][1], msg)
                    end
                end
            end
        end,
        totext = function(nodedata)
            local ret = "repeat " .. nodedata.attr[1] .. " times"
            local attr = nodedata.attr
            for i = 2, 11, 3 do
                if not IsBlank(attr[i]) then
                    ret = ret .. " (" .. attr[i] .. "=" .. attr[i + 1] .. ",increment " .. attr[i + 2] .. ")"
                end
            end
            return ret
        end,
        tohead = function(nodedata)
            local ret = "do "
            local attr = nodedata.attr
            for i = 2, 11, 3 do
                if not IsBlank(attr[i]) then
                    ret = ret .. string.format("local %s,%s=(%s),(%s) ", attr[i], "_d_" .. attr[i], attr[i + 1], attr[i + 2])
                end
            end
            return ret .. "for _=1," .. nodedata.attr[1] .. " do\n"
        end,
        tofoot = function(nodedata)
            local ret = ""
            local attr = nodedata.attr
            for i = 2, 11, 3 do
                if not IsBlank(attr[i]) then
                    ret = ret .. string.format("%s=%s+%s ", attr[i], attr[i], "_d_" .. attr[i])
                end
            end
            return ret .. "end end\n"
        end,
    },
    ['break'] = {
        { 'Condition', 'any' },
        default = { ["type"] = 'break', attr = { '' } },
        needancestor = { 'repeat', 'taskrepeat' },
        allowchild = {},
        totext = function(nodedata)
            if #nodedata.attr[1] == 0 then
                return "break"
            else
                return "if " .. nodedata.attr[1] .. " then break"
            end
        end,
        tohead = function(nodedata)
            local t = nodedata.attr[1]
            if #t == 0 then
                t = 'true'
            end
            return "if " .. t .. " then break end\n"
        end,
    },
    ['if'] = {
        { 'Condition', 'any', CheckExpr },
        editfirst = true,
        forbidparent = { 'root', 'folder' },
        depth = 0,
        allowchild = { 'else' },
        totext = function(nodedata)
            return "if " .. nodedata.attr[1]
        end,
        default = { ["attr"] = { "" }, ["type"] = "if", expand = true, child = { { ["attr"] = {}, ["type"] = "then" }, { ["attr"] = {}, ["type"] = "else" } } },
        tohead = function(nodedata)
            return "if " .. nodedata.attr[1] .. " then\n"
        end,
        tofoot = function()
            return "end\n"
        end,
    },
    ['then'] = {
        totext = function()
            return "then"
        end,
        allowparent = {},
        forbiddelete = true,
    },
    ['else'] = {
        { 'Condition', 'any' },
        totext = function(nodedata)
            if nodedata.attr[1] == '' then
                return "else"
            else
                return "else if " .. nodedata.attr[1]
            end
        end,
        allowparent = { 'if' },
        --forbiddelete=true,
        tohead = function(nodedata)
            if nodedata.attr[1] == '' then
                return "else\n"
            else
                return "elseif " .. nodedata.attr[1] .. " then\n"
            end
        end,
    },
    -- stage
    stagegroup = {
        { 'Name', 'stagegroup', CheckClassName },
        { 'Start life', 'any', CheckExpr },
        { 'Start power', 'any', CheckExpr },
        { 'Start faith', 'any', CheckExpr },
        { 'Start bomb', 'any', CheckExpr, '3' },
        { 'Allow practice', 'bool', CheckExpr },
        { 'Difficulty value', 'difficulty', CheckExpr, '1' },
        disptype = 'stage group',
        editfirst = true,
        default = { ["type"] = 'stagegroup', attr = { '', '2', '100', '50000', '3', 'true' } },
        allowchild = { 'stage', 'stagegroupinfo' },
        allowparent = { 'root', 'folder' },
        depth = 0,
        totext = function(nodedata)
            return string.format("stage group %q", nodedata.attr[1])
        end,
        tohead = function(nodedata)
            stageGroupName = nodedata.attr[1]
            return string.format("stage.group.New('menu',{},%q,{lifeleft=%s,power=%s,faith=%s,bomb=%s},%s,%s)\n",
                    nodedata.attr[1], nodedata.attr[2], nodedata.attr[3], nodedata.attr[4], nodedata.attr[5], nodedata.attr[6], nodedata.attr[7])
        end,
        check = function(nodedata)
            difficulty = nodedata.attr[1]
        end,
        checkafter = function()
            difficulty = nil
        end,
    },
    stagegroupinfo = {
        { 'Min Players', 'any', CheckExpr },
        { 'Max Players', 'any', CheckExpr },
        disptype = 'stage group info',
        default = { ["type"] = 'stagegroupinfo', attr = { '1', '2' } },
        allowparent = { 'stagegroup' },
        totext = function(nodedata)
            return string.format("players %s~%s", nodedata.attr[1], nodedata.attr[2])
        end,
        tohead = function(nodedata)
            return string.format("stage.groups['%s'].info={players={%s,%s}}\n", stageGroupName, nodedata.attr[1], nodedata.attr[2])
        end,
    },
    stage = {
        { 'Name', 'any', CheckName },
        { 'Start life (practice)', 'any', CheckExpr },
        { 'Start power (practice)', 'any', CheckExpr },
        { 'Start faith (practice)', 'any', CheckExpr },
        { 'Start spell (practice)', 'any', CheckExpr },
        { 'Allow practice', 'bool', CheckExpr },
        editfirst = true,
        allowparent = { 'stagegroup' },
        allowchild = {},
        depth = 1,
        default = { expand = true, ["type"] = 'stage', attr = { '', '7', '300', '50000', '3', 'true' }, child = { { ["type"] = 'stagetask', attr = {} } } },
        totext = function(nodedata)
            return string.format("stage %q", nodedata.attr[1])
        end,
        tohead = function(nodedata)
            local ret = string.format("stage.group.AddStage('%s','%s@%s',{lifeleft=%s,power=%s,faith=%s,bomb=%s},%s)\nstage.group.DefStageFunc('%s@%s','init',function(self)\n    _init_item(self)\n    difficulty=self.group.difficulty    New(mask_fader,'open')\n   New(_G[lstg.var.player_name])\n",
                    stageGroupName,
                    nodedata.attr[1],
                    stageGroupName,
                    nodedata.attr[2],
                    nodedata.attr[3],
                    nodedata.attr[4],
                    nodedata.attr[5],
                    nodedata.attr[6],
                    nodedata.attr[1],
                    stageGroupName)
            return ret
        end,
        tofoot = function()
            return "    task.New(self,function()\
		while coroutine.status(self.task[1])~='dead' do task.Wait() end\
		stage.group.FinishReplay()\
		New(mask_fader,'close')\
		task.New(self,function()\
			local _,bgm=EnumRes('bgm')\
			for i=1,30 do \
				for _,v in pairs(bgm) do\
					if GetMusicState(v)=='playing' then\
					SetBGMVolume(v,1-i/30) end\
				end\
				task.Wait()\
		end end)\
		task.Wait(30)\
		stage.group.FinishStage()\
	end)\
end)\n"
        end,
    },
    stagetask = {
        disptype = 'task for stage',
        allowparent = {},
        forbiddelete = true,
        totext = function()
            return "create task"
        end,
        tohead = function()
            return "task.New(self,function()\n"
        end,
        tofoot = function()
            return "end)\n"
        end,
    },
    stagefinish = {
        needancestor = { 'stage' },
        disptype = 'finish stage',
        allowchild = {},
        totext = function()
            return "finish current stage"
        end,
        tohead = function()
            return "if true then return end\n"
        end,
    },
    stagegoto = {
        { 'Stage (by index)', 'any', CheckExpr },
        disptype = 'go to stage',
        needancestor = { 'stage' },
        allowchild = {},
        totext = function(nodedata)
            return "go to stage " .. nodedata.attr[1]
        end,
        tohead = function(nodedata)
            return
            "New(mask_fader,'close')\
			task.New(self,function()\
				local _,bgm=EnumRes('bgm')\
				for i=1,30 do \
					for _,v in pairs(bgm) do\
						if GetMusicState(v)=='playing' then\
						SetBGMVolume(v,1-i/30) end\
					end\
					task.Wait()\
			end end)\
			task.Wait(30) stage.group.GoToStage(" .. nodedata.attr[1] .. ")\n"
        end,
    },
    stagefinishgroup = {
        disptype = 'finish stage group',
        needancestor = { 'stage' },
        allowchild = {},
        totext = function()
            return "finish current game and return to title"
        end,
        tohead = function()
            return "New(mask_fader,'close') _stop_music() task.Wait(30) stage.group.FinishGroup()\n"
        end,
    },
    bgstage = {
        { 'Background', 'bgstage', CheckVName },
        disptype = 'set stage background',
        needancestor = { 'stage' },
        allowchild = {},
        totext = function(nodedata)
            return string.format("set current stage's background to %q", nodedata.attr[1])
        end,
        tohead = function(nodedata)
            return string.format("New(%s_background)\n", nodedata.attr[1])
        end,
    },
    setworlds = {
        disptype = 'set worlds',
        allowchild = { 'addworld' },
        forbidparent = { 'root', 'folder' },
        totext = function()
            return string.format("set worlds")
        end,
        tohead = function()
            return 'jstg.worldcount=0 jstg.worlds={}\n'
        end,
        tofoot = function()
            return 'jstg.UpdateWorld()\n'
        end,
    },
    addworld = {
        { 'Width', 'any', CheckExpr },
        { 'Height', 'any', CheckExpr },
        { 'Bound', 'any', CheckExpr },
        { 'Left', 'any', CheckExpr },
        { 'Bottom', 'any', CheckExpr },
        { 'WorldMask', 'any', CheckExpr },
        disptype = 'add world',
        default = { ["type"] = 'addworld', attr = { '384', '448', '32', '32', '16', '7' } },
        needancestor = { 'setworlds' },
        totext = function(nodedata)
            return string.format("World Size (%s * %s), left = %s, bottom = %s, mask = %s", nodedata.attr[1], nodedata.attr[2], nodedata.attr[4], nodedata.attr[5], nodedata.attr[6])
        end,
        tohead = function(nodedata)
            return string.format("jstg.worldcount=jstg.worldcount+1 jstg.worlds[jstg.worldcount]={} \nSetLuaSTGWorld2(jstg.worlds[jstg.worldcount],%s,%s,%s,%s,%s,%s)\n", nodedata.attr[1], nodedata.attr[2], nodedata.attr[3], nodedata.attr[4], nodedata.attr[5], nodedata.attr[6])
        end,
    },
    -- task
	task={
		{ 'Target', 'target', CheckExpr },
		{ 'Set self to the target', 'bool', CheckExpr },
		default = {
			["type"] = 'task',
			["attr"] = { 'self', 'false' }
		},
		needancestor = { 'enemydefine', 'bossdefine', 'objectdefine', 'laserdefine', 'laserbentdefine', 'bulletdefine', 'rebounderdefine',
						 'enemysimple', 'renderimage', 'task', 'taskdefine', 'stagetask', 'tasker', 'bglayer', 'bossspellcardex', 'bossexdefine' },
		totext = function(nodedata)
			local target
			if IsBlank(nodedata.attr[1]) then
				target = "self"
			else
				target = nodedata.attr[1]
			end
			local info = "create task to " .. target
			if nodedata.attr[2] ~= "false" then
			    info = info .. " and set self to " .. target .. " in this task"
			end
			return info
		end,
		tohead = function(nodedata)
			local target
			if IsBlank(nodedata.attr[1]) then
				target = "self"
			else
				target = nodedata.attr[1]
			end
			if nodedata.attr[2] == "false" then
				return string.format("lasttask=task.New(%s,function()\n", target)
			else
				return string.format("lasttask=task.New(%s,function()\n    local self=task.GetSelf()\n", target)
			end
		end,
		tofoot = function(nodedata) return "end)\n" end,
	},
    tasker = {
        forbidparent = { 'root', 'folder' },
        totext = function()
            return "create tasker"
        end,
        tohead = function()
            return "New(tasker, function()\n"
        end,
        tofoot = function()
            return "end)\n"
        end,
    },
    taskclear = {
        { 'keep this', 'bool' },
        disptype = 'clear task',
        needancestor = { 'enemydefine', 'bossdefine', 'objectdefine', 'laserdefine', 'laserbentdefine', 'bulletdefine', 'rebounderdefine', 'taskdefine', 'bossspellcardex' },
        allowchild = {},
        totext = function(nodedata)
            if IsBlank(nodedata.attr[1]) or nodedata.attr[1] == 'false' then
                return "clear all task(s)"
            else
                return "clear all other task(s)"
            end
        end,
        tohead = function(nodedata)
            if IsBlank(nodedata.attr[1]) or nodedata.attr[1] == 'false' then
                return "task.Clear(self)\n"
            else
                return "task.Clear(self," .. nodedata.attr[1] .. ")\n"
            end
        end,
    },
    taskwait = {
        { 'nFrame', 'any', CheckExpr },
        disptype = 'wait',
        default = { ["type"] = 'taskwait', attr = { '60' } },
        needancestor = { 'task', 'bossscbefore', 'taskdefine', 'stagetask', 'dialogtask', 'tasker' },
        allowchild = {},
        totext = function(nodedata)
            return "wait " .. nodedata.attr[1] .. " frame(s)"
        end,
        tohead = function(nodedata)
            return "task._Wait(" .. nodedata.attr[1] .. ")\n"
        end,
    },
    taskwaitto = {
        { 'vStageTime', 'any', CheckExpr },
        { 'Unit', 'timeunit', CheckExpr },
        { 'Discard', 'bool', CheckExpr },
        { 'Add', 'bool', CheckExpr },
        disptype = 'wait to',
        default = { ["type"] = 'taskwaitto', attr = { '4.0', 'UNIT_MUSIC', 'false', 'false' } },
        needancestor = { 'task', 'bossscbefore', 'taskdefine', 'stagetask', 'dialogtask', 'tasker' },
        --allowchild={},
        totext = function(nodedata)
            local z = ' second(s)'
            local h = "wait to "
            if nodedata.attr[4] == 'true' then
                h = "wait "
            end
            if nodedata.attr[2] == 'UNIT_FRAME' then
                z = ' frame(s)'
            end
            if nodedata.attr[2] == 'UNIT_MUSIC' then
                z = ' pace(s)'
            end
            if nodedata.attr[3] == 'true' then
                return h .. nodedata.attr[1] .. z .. " or next"
            end
            return h .. nodedata.attr[1] .. z
        end,
        tohead = function(nodedata)
            local s1 = 'if ex.WaitTo(' .. nodedata.attr[1] .. ',' .. nodedata.attr[2] .. ',' .. nodedata.attr[3] .. ',' .. nodedata.attr[4] .. ') then\n'
            return s1
        end,
        tofoot = function()
            return "end\n"
        end,
    },
    taskwaitfor = {
        { 'SignalName', 'any', CheckNonBlank },
        { 'Value', 'any', CheckExpr },
        disptype = 'wait for a signal',
        --default={["type"]='taskwait',attr={'60'}},
        needancestor = { 'task', 'bossscbefore', 'taskdefine', 'stagetask', 'dialogtask', 'tasker' },
        allowchild = {},
        totext = function(nodedata)
            return "wait for signal " .. nodedata.attr[1] .. " to be " .. nodedata.attr[2]
        end,
        tohead = function(nodedata)
            return "ex.WaitForSignal('" .. nodedata.attr[1] .. "'," .. nodedata.attr[2] .. ")\n"
        end,
    },
    signal = {
        { 'SignalName', 'any', CheckNonBlank },
        { 'Value', 'any', CheckExpr },
        allowchild = {},
        disptype = 'set signal',
        totext = function(nodedata)
            return "send signal " .. nodedata.attr[1] .. " as " .. nodedata.attr[2]
        end,
        tohead = function(nodedata)
            return "ex.SetSignal('" .. nodedata.attr[1] .. "'," .. nodedata.attr[2] .. ")\n"
        end,
    },
    taskrepeat = {
        { 'Number of times', 'any', CheckExpr },
        { 'Interval (in frames)', 'any', CheckExpr },
        { 'Var 1 name', 'any' },
        { 'Var 1 init value', 'any' },
        { 'Var 1 increment', 'any' },
        { 'Var 2 name', 'any' },
        { 'Var 2 init value', 'any' },
        { 'Var 2 increment', 'any' },
        { 'Var 3 name', 'any' },
        { 'Var 3 init value', 'any' },
        { 'Var 3 increment', 'any' },
        { 'Var 4 name', 'any' },
        { 'Var 4 init value', 'any' },
        { 'Var 4 increment', 'any' },
        disptype = 'repeat',
        default = { ["type"] = 'taskrepeat', attr = { '_infinite', '60', '', '', '', '', '', '', '', '', '', '', '', '' } },
        needancestor = { 'task', 'bossscbefore', 'taskdefine', 'stagetask', 'dialogtask', 'tasker' },
        check = function(nodedata)
            local attr = nodedata.attr
            for i = 3, 12, 3 do
                if not IsBlank(attr[i]) then
                    local msg = CheckVName(attr[i])
                    if msg then
                        return string.format("Attribution '%s' is invalid: %s", nodeType["taskrepeat"][i][1], msg)
                    end
                    msg = CheckExpr(attr[i + 1])
                    if msg then
                        return string.format("Attribution '%s' is invalid: %s", nodeType["taskrepeat"][i + 1][1], msg)
                    end
                    msg = CheckExpr(attr[i + 2])
                    if msg then
                        return string.format("Attribution '%s' is invalid: %s", nodeType["taskrepeat"][i + 2][1], msg)
                    end
                end
            end
        end,
        totext = function(nodedata)
            local ret = "repeat " .. nodedata.attr[1] .. " times"
            local attr = nodedata.attr
            if not IsBlank(attr[2]) then
                ret = ret .. ",interval " .. attr[2] .. " frame(s)"
            end
            for i = 3, 12, 3 do
                if not IsBlank(attr[i]) then
                    ret = ret .. " (" .. attr[i] .. "=" .. attr[i + 1] .. ",increment " .. attr[i + 2] .. ")"
                end
            end
            return ret
        end,
        tohead = function(nodedata)
            local ret = "do "
            local attr = nodedata.attr
            for i = 3, 12, 3 do
                if not IsBlank(attr[i]) then
                    ret = ret .. string.format("local %s,%s=(%s),(%s) ", attr[i], "_d_" .. attr[i], attr[i + 1], attr[i + 2])
                end
            end
            return ret .. "for _=1," .. nodedata.attr[1] .. " do\n"
        end,
        tofoot = function(nodedata)
            local ret = ""
            local attr = nodedata.attr
            if not IsBlank(attr[2]) then
                ret = ret .. "    task._Wait(" .. attr[2] .. ")\n"
            end
            for i = 3, 12, 3 do
                if not IsBlank(attr[i]) then
                    ret = ret .. string.format("%s=%s+%s ", attr[i], attr[i], "_d_" .. attr[i])
                end
            end
            return ret .. "end end\n"
        end,
    },
    taskbreak = {
        { 'Condition', 'any' },
        default = { ["type"] = 'taskbreak', attr = { '' } },
        needancestor = { 'repeat', 'taskrepeat' },
        disptype = 'jump',
        allowchild = {},
        totext = function(nodedata)
            if #nodedata.attr[1] == 0 then
                return "jump of the current repeat"
            else
                return "if " .. nodedata.attr[1] .. " then jump of the current repeat"
            end
        end,
        tohead = function(nodedata)
            local t = nodedata.attr[1]
            if #t == 0 then
                t = 'true'
            end
            return "if " .. t .. " then break end\n"
        end,
    },
    taskreturn = {
        needancestor = { 'task', 'bossscbefore', 'taskdefine', 'dialogtask', 'tasker' },
        disptype = 'terminate task',
        allowchild = {},
        totext = function()
            return "terminate current task"
        end,
        tohead = function()
            return "do return end\n"
        end,
    },
    tasksetvalue = {
        { 'Target', 'target' },
        { 'ValueName', 'propertiesval', CheckNonBlank },
        { 'TargetValue', 'any', CheckExpr },
        { 'nFrame', 'any', CheckExprOmit },
        { 'Mode', 'movetomode', CheckExprOmit },
        { 'StartTime', 'any', CheckExprOmit },
        { 'ValueMode', 'valuemode', CheckExprOmit },
        disptype = 'set value to',
        needancestor = { 'task', 'bossscbefore', 'taskdefine', 'dialogtask', 'tasker' },
        allowchild = {},
        default = { ["attr"] = { "self", "_speed", "3", "60", "MOVE_NORMAL" }, ["type"] = "tasksetvalue" },
        totext = function(nodedata)
            local nf
            if IsBlank(nodedata.attr[1]) then
                nf = nodedata.attr[2]
            else
                nf = nodedata.attr[1] .. '.' .. nodedata.attr[2]
            end
            local nt
            if IsBlank(nodedata.attr[4]) then
                nt = '1'
            else
                nt = nodedata.attr[4]
            end
            local action = ''
            if IsBlank(nodedata.attr[7]) or nodedata.attr[7] == 'MODE_SET' then
                action = "set " .. nf .. " to "
            elseif nodedata.attr[7] == 'MODE_ADD' then
                action = "add " .. nf .. " by "
            elseif nodedata.attr[7] == 'MODE_MUL' then
                action = "mul " .. nf .. " by "
            else
                action = "change " .. nf .. " by "
            end
            local rt = action .. "(" .. nodedata.attr[3] .. ") in " .. nt .. " frame(s)"
            if not IsBlank(nodedata.attr[6]) then
                rt = 'wait ' .. nodedata.attr[6] .. ' frames, ' .. rt
            end
            return rt
        end,
        tohead = function(nodedata)
            local nf, mode, getter, setter, binder, start, vmode
            if IsBlank(nodedata.attr[1]) then
                getter = 'function () return ' .. nodedata.attr[2] .. ' end'
            else
                getter = '"' .. nodedata.attr[2] .. '"'
            end
            if IsBlank(nodedata.attr[1]) then
                setter = 'function (__) ' .. nodedata.attr[2] .. '=__ end'
            else
                setter = 'nil'
            end
            if IsBlank(nodedata.attr[1]) then
                binder = 'self'
            else
                binder = nodedata.attr[1]
            end

            if IsBlank(nodedata.attr[4]) then
                nf = '1'
            else
                nf = nodedata.attr[4]
            end
            if IsBlank(nodedata.attr[5]) then
                mode = 'MOVE_NORMAL'
            else
                mode = nodedata.attr[5]
            end
            if IsBlank(nodedata.attr[6]) then
                start = '0'
            else
                start = nodedata.attr[6]
            end
            if IsBlank(nodedata.attr[7]) then
                vmode = 'MODE_SET'
            else
                vmode = nodedata.attr[7]
            end
            return string.format("lasttask=task.New(%s,function () ex.SmoothSetValueTo(%s,%s,%s,%s,%s,%s,%s) end )\n", binder, getter, nodedata.attr[3], nf, mode, setter, start, vmode)
        end,
    },
    --task move
    taskmoveto = {
        { 'Destination', 'any', CheckExpr },
        { 'nFrame', 'any', CheckExprOmit },
        { 'Mode', 'movetomode', CheckExprOmit },
        disptype = 'move to',
        needancestor = { 'task', 'bossscbefore', 'taskdefine', 'dialogtask', 'tasker' },
        allowchild = {},
        default = { ["attr"] = { "0,0", "60", "MOVE_NORMAL" }, ["type"] = "taskmoveto" },
        totext = function(nodedata)
            local nf
            if IsBlank(nodedata.attr[2]) then
                nf = '1'
            else
                nf = nodedata.attr[2]
            end
            return "move to (" .. nodedata.attr[1] .. ") in " .. nf .. " frame(s)"
        end,
        tohead = function(nodedata)
            local nf, mode
            if IsBlank(nodedata.attr[2]) then
                nf = '1'
            else
                nf = nodedata.attr[2]
            end
            if IsBlank(nodedata.attr[3]) then
                mode = 'MOVE_NORMAL'
            else
                mode = nodedata.attr[3]
            end
            return string.format("task.MoveTo(%s,%s,%s)\n", nodedata.attr[1], nf, mode)
        end,
    },
    taskmovetoex = {
        { 'Destination', 'any', CheckExpr },
        { 'nFrame', 'any', CheckExprOmit },
        { 'Mode', 'movetomode', CheckExprOmit },
        disptype = 'move by',
        needancestor = { 'task', 'bossscbefore', 'taskdefine', 'dialogtask', 'tasker' },
        allowchild = {},
        default = { ["attr"] = { "0,0", "60", "MOVE_NORMAL" }, ["type"] = "taskmovetoex" },
        totext = function(nodedata)
            local nf
            if IsBlank(nodedata.attr[2]) then
                nf = '1'
            else
                nf = nodedata.attr[2]
            end
            return "move by (" .. nodedata.attr[1] .. ") in " .. nf .. " frame(s)"
        end,
        tohead = function(nodedata)
            local nf, mode
            if IsBlank(nodedata.attr[2]) then
                nf = '1'
            else
                nf = nodedata.attr[2]
            end
            if IsBlank(nodedata.attr[3]) then
                mode = 'MOVE_NORMAL'
            else
                mode = nodedata.attr[3]
            end
            return string.format("task.MoveToEx(%s,%s,%s)\n", nodedata.attr[1], nf, mode)
        end,
    },
    taskBeziermoveto = {
        { 'nFrame', 'any', CheckExprOmit },
        { 'Mode', 'movetomode', CheckExprOmit },
        { 'Point 1', 'any', CheckExpr },
        { 'Point 2', 'any', },
        { 'Point 3', 'any', },
        { 'Point 4', 'any', },
        { 'Point 5', 'any', },
        disptype = 'move to by Bezier Curve',
        needancestor = { 'task', 'bossscbefore', 'taskdefine', 'dialogtask', 'tasker' },
        allowchild = {},
        default = { ["attr"] = { "60", "MOVE_NORMAL", "0,0", "", "", "", "" }, ["type"] = "taskBeziermoveto" },
        totext = function(nodedata)
            local nf
            if IsBlank(nodedata.attr[1]) then
                nf = '1'
            else
                nf = nodedata.attr[1]
            end
            local str = nodedata.attr[3]
            for i = 4, 7 do
                if IsBlank(nodedata.attr[i]) then
                    break
                else
                    str = str .. '),(' .. nodedata.attr[i]
                end
            end
            return "move to (" .. str .. ") in " .. nf .. " frame(s) by Bezier Curve"
        end,
        tohead = function(nodedata)
            local nf, mode
            if IsBlank(nodedata.attr[1]) then
                nf = '1'
            else
                nf = nodedata.attr[1]
            end
            if IsBlank(nodedata.attr[2]) then
                mode = 'MOVE_NORMAL'
            else
                mode = nodedata.attr[2]
            end
            local str = nodedata.attr[3]
            for i = 4, 7 do
                if IsBlank(nodedata.attr[i]) then
                    break
                else
                    str = str .. ',' .. nodedata.attr[i]
                end
            end
            return string.format("task.BezierMoveTo(%s,%s,%s)\n", nf, mode, str)
        end,
    },
    taskBeziermovetoex = {
        { 'nFrame', 'any', CheckExprOmit },
        { 'Mode', 'movetomode', CheckExprOmit },
        { 'Point 1', 'any', CheckExpr },
        { 'Point 2', 'any', },
        { 'Point 3', 'any', },
        { 'Point 4', 'any', },
        { 'Point 5', 'any', },
        disptype = 'move by with Bezier Curve',
        needancestor = { 'task', 'bossscbefore', 'taskdefine', 'dialogtask', 'tasker' },
        allowchild = {},
        default = { ["attr"] = { "60", "MOVE_NORMAL", "0,0", "", "", "", "" }, ["type"] = "taskBeziermovetoex" },
        totext = function(nodedata)
            local nf
            if IsBlank(nodedata.attr[1]) then
                nf = '1'
            else
                nf = nodedata.attr[1]
            end
            local str = nodedata.attr[3]
            for i = 4, 7 do
                if IsBlank(nodedata.attr[i]) then
                    break
                else
                    str = str .. '),(' .. nodedata.attr[i]
                end
            end
            return "move by (" .. str .. ") in " .. nf .. " frame(s) with Bezier Curve"
        end,
        tohead = function(nodedata)
            local nf, mode
            if IsBlank(nodedata.attr[1]) then
                nf = '1'
            else
                nf = nodedata.attr[1]
            end
            if IsBlank(nodedata.attr[2]) then
                mode = 'MOVE_NORMAL'
            else
                mode = nodedata.attr[2]
            end
            local str = nodedata.attr[3]
            for i = 4, 7 do
                if IsBlank(nodedata.attr[i]) then
                    break
                else
                    str = str .. ',' .. nodedata.attr[i]
                end
            end
            return string.format("task.BezierMoveToEx(%s,%s,%s)\n", nf, mode, str)
        end,
    },
    taskCRmoveto = {
        { 'nFrame', 'any', CheckExprOmit },
        { 'Mode', 'movetomode', CheckExprOmit },
        { 'Point 1', 'any', CheckExpr },
        { 'Point 2', 'any', },
        { 'Point 3', 'any', },
        { 'Point 4', 'any', },
        { 'Point 5', 'any', },
        { 'Point 6', 'any', },
        { 'Point 7', 'any', },
        { 'Point 8', 'any', },
        disptype = 'move to by catmull-rom spline',
        needancestor = { 'task', 'bossscbefore', 'taskdefine', 'dialogtask', 'tasker' },
        allowchild = {},
        default = { ["attr"] = { "60", "MOVE_NORMAL", "0,0", "", "", "", "" }, ["type"] = "taskCRmoveto" },
        totext = function(nodedata)
            local nf
            if IsBlank(nodedata.attr[1]) then
                nf = '1'
            else
                nf = nodedata.attr[1]
            end
            local str = nodedata.attr[3]
            for i = 4, 10 do
                if IsBlank(nodedata.attr[i]) then
                    break
                else
                    str = str .. '),(' .. nodedata.attr[i]
                end
            end
            return "move to (" .. str .. ") in " .. nf .. " frame(s) by catmull-rom spline"
        end,
        tohead = function(nodedata)
            local nf, mode
            if IsBlank(nodedata.attr[1]) then
                nf = '1'
            else
                nf = nodedata.attr[1]
            end
            if IsBlank(nodedata.attr[2]) then
                mode = 'MOVE_NORMAL'
            else
                mode = nodedata.attr[2]
            end
            local str = nodedata.attr[3]
            for i = 4, 10 do
                if IsBlank(nodedata.attr[i]) then
                    break
                else
                    str = str .. ',' .. nodedata.attr[i]
                end
            end
            return string.format("task.CRMoveTo(%s,%s,%s)\n", nf, mode, str)
        end,
    },
    taskCRmovetoex = {
        { 'nFrame', 'any', CheckExprOmit },
        { 'Mode', 'movetomode', CheckExprOmit },
        { 'Point 1', 'any', CheckExpr },
        { 'Point 2', 'any', },
        { 'Point 3', 'any', },
        { 'Point 4', 'any', },
        { 'Point 5', 'any', },
        { 'Point 6', 'any', },
        { 'Point 7', 'any', },
        { 'Point 8', 'any', },
        disptype = 'move to by catmull-rom spline',
        needancestor = { 'task', 'bossscbefore', 'taskdefine', 'dialogtask', 'tasker' },
        allowchild = {},
        default = { ["attr"] = { "60", "MOVE_NORMAL", "0,0", "", "", "", "" }, ["type"] = "taskCRmovetoex" },
        totext = function(nodedata)
            local nf
            if IsBlank(nodedata.attr[1]) then
                nf = '1'
            else
                nf = nodedata.attr[1]
            end
            local str = nodedata.attr[3]
            for i = 4, 10 do
                if IsBlank(nodedata.attr[i]) then
                    break
                else
                    str = str .. '),(' .. nodedata.attr[i]
                end
            end
            return "move to (" .. str .. ") in " .. nf .. " frame(s) by catmull-rom spline"
        end,
        tohead = function(nodedata)
            local nf, mode
            if IsBlank(nodedata.attr[1]) then
                nf = '1'
            else
                nf = nodedata.attr[1]
            end
            if IsBlank(nodedata.attr[2]) then
                mode = 'MOVE_NORMAL'
            else
                mode = nodedata.attr[2]
            end
            local str = nodedata.attr[3]
            for i = 4, 10 do
                if IsBlank(nodedata.attr[i]) then
                    break
                else
                    str = str .. ',' .. nodedata.attr[i]
                end
            end
            return string.format("task.CRMoveToEx(%s,%s,%s)\n", nf, mode, str)
        end,
    },
    taskB2moveto = {
        { 'nFrame', 'any', CheckExprOmit },
        { 'Mode', 'movetomode', CheckExprOmit },
        { 'Point 1', 'any', CheckExpr },
        { 'Point 2', 'any', },
        { 'Point 3', 'any', },
        { 'Point 4', 'any', },
        { 'Point 5', 'any', },
        { 'Point 6', 'any', },
        { 'Point 7', 'any', },
        { 'Point 8', 'any', },
        disptype = 'move to by Basis2 spline',
        needancestor = { 'task', 'bossscbefore', 'taskdefine', 'dialogtask', 'tasker' },
        allowchild = {},
        default = { ["attr"] = { "60", "MOVE_NORMAL", "0,0", "", "", "", "" }, ["type"] = "taskB2moveto" },
        totext = function(nodedata)
            local nf
            if IsBlank(nodedata.attr[1]) then
                nf = '1'
            else
                nf = nodedata.attr[1]
            end
            local str = nodedata.attr[3]
            for i = 4, 10 do
                if IsBlank(nodedata.attr[i]) then
                    break
                else
                    str = str .. '),(' .. nodedata.attr[i]
                end
            end
            return "move to (" .. str .. ") in " .. nf .. " frame(s) by Basis2 spline"
        end,
        tohead = function(nodedata)
            local nf, mode
            if IsBlank(nodedata.attr[1]) then
                nf = '1'
            else
                nf = nodedata.attr[1]
            end
            if IsBlank(nodedata.attr[2]) then
                mode = 'MOVE_NORMAL'
            else
                mode = nodedata.attr[2]
            end
            local str = nodedata.attr[3]
            for i = 4, 10 do
                if IsBlank(nodedata.attr[i]) then
                    break
                else
                    str = str .. ',' .. nodedata.attr[i]
                end
            end
            return string.format("task.Basis2MoveTo(%s,%s,%s)\n", nf, mode, str)
        end,
    },
    taskB2movetoex = {
        { 'nFrame', 'any', CheckExprOmit },
        { 'Mode', 'movetomode', CheckExprOmit },
        { 'Point 1', 'any', CheckExpr },
        { 'Point 2', 'any', },
        { 'Point 3', 'any', },
        { 'Point 4', 'any', },
        { 'Point 5', 'any', },
        { 'Point 6', 'any', },
        { 'Point 7', 'any', },
        { 'Point 8', 'any', },
        disptype = 'move to by Basis2 spline',
        needancestor = { 'task', 'bossscbefore', 'taskdefine', 'dialogtask', 'tasker' },
        allowchild = {},
        default = { ["attr"] = { "60", "MOVE_NORMAL", "0,0", "", "", "", "" }, ["type"] = "taskB2movetoex" },
        totext = function(nodedata)
            local nf
            if IsBlank(nodedata.attr[1]) then
                nf = '1'
            else
                nf = nodedata.attr[1]
            end
            local str = nodedata.attr[3]
            for i = 4, 10 do
                if IsBlank(nodedata.attr[i]) then
                    break
                else
                    str = str .. '),(' .. nodedata.attr[i]
                end
            end
            return "move to (" .. str .. ") in " .. nf .. " frame(s) by Basis2 spline"
        end,
        tohead = function(nodedata)
            local nf, mode
            if IsBlank(nodedata.attr[1]) then
                nf = '1'
            else
                nf = nodedata.attr[1]
            end
            if IsBlank(nodedata.attr[2]) then
                mode = 'MOVE_NORMAL'
            else
                mode = nodedata.attr[2]
            end
            local str = nodedata.attr[3]
            for i = 4, 10 do
                if IsBlank(nodedata.attr[i]) then
                    break
                else
                    str = str .. ',' .. nodedata.attr[i]
                end
            end
            return string.format("task.Basis2MoveToEX(%s,%s,%s)\n", nf, mode, str)
        end,
    },
    taskbosswander = {
        { 'nFrame', 'any', CheckExprOmit },
        { 'X Range', 'any', CheckExprOmit },
        { 'Y Range', 'any', CheckExprOmit },
        { 'X Amplitude', 'any', CheckExprOmit },
        { 'Y Amplitude', 'any', CheckExprOmit },
        { 'Movement Mode', 'movetomode', CheckExprOmit },
        { 'Direction Mode', 'directmode', CheckExprOmit },
        disptype = 'boss wander',
        default = { ["attr"] = { "60", "-96,96", "112,144", "16,32", "8,16", "MOVE_NORMAL", "MOVE_X_TOWARDS_PLAYER" },
                    ["type"] = "taskbosswander" },
        needancestor = { 'task', 'bossscbefore', 'taskdefine', 'tasker' },
        forbidancestor = { 'bulletdefine', 'laserdefine', 'laserbentdefine', 'enemydefine' },
        allowchild = {},
        totext = function(nodedata)
            local nf
            if IsBlank(nodedata.attr[1]) then
                nf = '1'
            else
                nf = nodedata.attr[1]
            end
            if IsBlank(nodedata.attr[2]) then
                nodedata.attr[2] = "-96,96"
            end
            if IsBlank(nodedata.attr[3]) then
                nodedata.attr[3] = "112,144"
            end
            if IsBlank(nodedata.attr[4]) then
                nodedata.attr[4] = "16,32"
            end
            if IsBlank(nodedata.attr[5]) then
                nodedata.attr[5] = "8,16"
            end
            local mmode, dmode
            if IsBlank(nodedata.attr[6]) then
                mmode = "MOVE_NORMAL"
            else
                mmode = nodedata.attr[6]
            end
            if IsBlank(nodedata.attr[7]) then
                dmode = "MOVE_X_TOWARDS_PLAYER"
            else
                dmode = nodedata.attr[7]
            end
            return "boss wander " .. nf .. " frame(s), range of (" .. nodedata.attr[2] .. "):(" .. nodedata.attr[3] .. "), " ..
                    "X amplitude of " .. nodedata.attr[4] .. ", " .. "Y amplitude of " .. nodedata.attr[5] .. "," .. nodedata.attr[6] .. ", " .. nodedata.attr[7]
        end,
        tohead = function(nodedata)
            local nf
            if IsBlank(nodedata.attr[1]) then
                nf = '1'
            else
                nf = nodedata.attr[1]
            end
            if IsBlank(nodedata.attr[2]) then
                nodedata.attr[2] = "-96,96"
            end
            if IsBlank(nodedata.attr[3]) then
                nodedata.attr[3] = "112,144"
            end
            if IsBlank(nodedata.attr[4]) then
                nodedata.attr[4] = "16,32"
            end
            if IsBlank(nodedata.attr[5]) then
                nodedata.attr[5] = "8,16"
            end
            local mmode, dmode
            if IsBlank(nodedata.attr[6]) then
                mmode = "MOVE_NORMAL"
            else
                mmode = nodedata.attr[6]
            end
            if IsBlank(nodedata.attr[7]) then
                dmode = "MOVE_X_TOWARDS_PLAYER"
            else
                dmode = nodedata.attr[7]
            end
            return string.format("task.MoveToPlayer(%s,%s,%s,%s,%s,%s,%s)\n", nf, nodedata.attr[2], nodedata.attr[3],
                    nodedata.attr[4], nodedata.attr[5], mmode, dmode)
        end,
    },
    --task ex
    taskdefine = {
        { 'Task name', 'typename', CheckClassName },
        { 'Parameter list', 'any', CheckParam },
        disptype = 'define task',
        editfirst = true,
        allowparent = { 'root', 'folder' },
        --allowchild={'callbackfunc'},
        totext = function(nodedata)
            return string.format("define task %q (%s)", nodedata.attr[1], nodedata.attr[2])
        end,
        --depth=0,
        watch = 'taskdefine',
        default = {
            ["attr"] = { "", "" },
            ["type"] = "taskdefine",
            ["expand"] = true,
        },
        tohead = function(nodedata)
            --local v=''
            --if ~IsBlank(nodedata.attr[2]) then
            --	v='~'
            --end

            return string.format("_editor_tasks[%q]=function(%s)\nreturn function()\nlocal self=task.GetSelf()\n", nodedata.attr[1], nodedata.attr[2]);
        end,
        tofoot = function()
            return 'end\nend\n'
        end,
        --check=function(nodedata) difficulty=string.match(nodedata.attr[1],'^.+:(.+)$') end,
        --checkafter=function(nodedata) difficulty=nil end,
    },
    taskattach = {
        { 'Task name', 'selecttype', CheckNonBlank },
        { 'Parameter', 'param', CheckExprOmit },
        { 'Target', 'target', CheckNonBlank },
        disptype = 'attach task',
        editfirst = true,
        default = { ["type"] = 'taskattach', attr = { '', '', 'self' } },
        forbidparent = { 'root', 'folder' },
        allowchild = {},
        totext = function(nodedata)
            return string.format("attach task %q to (%s) with parameter %s", nodedata.attr[1], nodedata.attr[3], nodedata.attr[2])
        end,
        tohead = function(nodedata)
            return string.format("lasttask=task.New(%s,_editor_tasks[%q](%s))\n", nodedata.attr[3], nodedata.fullclassname, nodedata.attr[2])
        end,
        check = function(nodedata)
            local class
            if difficulty and watchDict.taskdefine[nodedata.attr[1] .. ':' .. difficulty] then
                class = nodedata.attr[1] .. ':' .. difficulty
            elseif watchDict.taskdefine[nodedata.attr[1]] then
                class = nodedata.attr[1]
            else
                return string.format('task %q does not exist', nodedata.attr[1])
            end
            if paramNumDict[class] ~= CalcParamNum(nodedata.attr[2]) then
                return "number of parameter is incorrect"
            end
            nodedata.fullclassname = class
        end,
    },
    --enemy
    enemydefine = {
        { 'Type name', 'typename', CheckClassName },
        disptype = 'define enemy',
        editfirst = true,
        allowparent = { 'root', 'folder' },
        allowchild = { 'callbackfunc' },
        totext = function(nodedata)
            return string.format("define enemy type %q", nodedata.attr[1])
        end,
        depth = 0,
        watch = 'enemydefine',
        default = {
            ["attr"] = {
                [1] = "",
            },
            ["type"] = "enemydefine",
            ["expand"] = true,
            ["child"] = {
                [1] = {
                    ["attr"] = { "", "1", "10", "0", "0", "0", "1", "false", "true", "false" },
                    ["type"] = "enemyinit",
                    ["expand"] = true,
                    ["child"] = {
                        [1] = {
                            ["attr"] = {
                            },
                            ["type"] = "task",
                            ["child"] = {
                            },
                        },
                    },
                },
            },
        },
        tohead = function(nodedata)
            className = nodedata.attr[1]
            difficulty = string.match(nodedata.attr[1], '^.+:(.+)$')
            return string.format("_editor_class[%q]=Class(enemy)\n", className)
        end,
        tofoot = function()
            difficulty = nil
            return ''
        end,
        check = function(nodedata)
            difficulty = string.match(nodedata.attr[1], '^.+:(.+)$')
        end,
        checkafter = function()
            difficulty = nil
        end,
    },
    enemyinit = {
        { 'Parameter list', 'any', CheckParam },
        { 'Style', 'selectenemystyle', CheckExpr },
        { 'Hit point', 'any', CheckExpr },
        { 'Drop power item', 'any', CheckExpr },
        { 'Drop faith item', 'any', CheckExpr },
        { 'Drop point item', 'any', CheckExpr },
        { 'Protect (nframes)', 'any', CheckExpr },
        { 'Clear bullets when die', 'bool', CheckExpr },
        { 'Delete when leave screen', 'bool', CheckExpr },
        { 'Taijutsu nashi', 'bool', CheckExpr },
        disptype = 'on create enemy',
        allowparent = {},
        forbiddelete = true,
        totext = function(nodedata)
            return string.format("on create: (%s)", nodedata.attr[1])
        end,
        tohead = function(nodedata)
            local p
            if IsBlank(nodedata.attr[1]) then
                p = '_'
            else
                p = nodedata.attr[1]
            end
            return string.format("_editor_class[%q].init=function(self,_x,_y,%s)\
	enemy.init(self,%s,%s,%s,%s,%s)\
	self.x,self.y=_x,_y\
	self.drop={%s,%s,%s}\
	task.New(self,function() self.protect=true task.Wait(%s) self.protect=false end)\
", className, p, nodedata.attr[2], nodedata.attr[3], nodedata.attr[8], nodedata.attr[9], nodedata.attr[10], nodedata.attr[4], nodedata.attr[5], nodedata.attr[6], nodedata.attr[7])
        end,
        tofoot = function()
            return "end\n"
        end,
    },
    enemycreate = {
        { 'Type name', 'selecttype', CheckNonBlank },
        { 'Position', 'any', CheckPos },
        { 'Parameter', 'param', CheckExprOmit },
        disptype = 'create enemy',
        editfirst = true,
        forbidparent = { 'root', 'folder' },
        allowchild = {},
        totext = function(nodedata)
            return string.format("create enemy of type %q in (%s) with parameter %s", nodedata.attr[1], nodedata.attr[2], nodedata.attr[3])
        end,
        tohead = function(nodedata)
            local p
            if IsBlank(nodedata.attr[3]) then
                p = "_"
            else
                p = nodedata.attr[3]
            end
            return string.format("last=New(_editor_class[%q],%s,%s)\n", nodedata.fullclassname, nodedata.attr[2], p)
        end,
        check = function(nodedata)
            local class
            if difficulty and watchDict.enemydefine[nodedata.attr[1] .. ':' .. difficulty] then
                class = nodedata.attr[1] .. ':' .. difficulty
            elseif watchDict.enemydefine[nodedata.attr[1]] then
                class = nodedata.attr[1]
            else
                return string.format('enemy type %q does not exist', nodedata.attr[1])
            end
            if paramNumDict[class] ~= CalcParamNum(nodedata.attr[3]) then
                return "number of parameter is incorrect"
            end
            nodedata.fullclassname = class
        end,
    },
    enemysimple = {
        { 'Style', 'selectenemystyle', CheckExpr },
        { 'Hit point', 'any', CheckExpr },
        { 'Position', 'any', CheckPos },
        { 'Drop power item', 'any', CheckExpr },
        { 'Drop faith item', 'any', CheckExpr },
        { 'Drop point item', 'any', CheckExpr },
        { 'Protect (nframes)', 'any', CheckExpr },
        { 'Clear bullets when die', 'bool', CheckExpr },
        { 'Delete when leave screen', 'bool', CheckExpr },
        { 'Taijutsu nashi', 'bool', CheckExpr },
        disptype = 'create simple enemy with task',
        forbidparent = { 'root', 'folder' },
        allowchild = { 'task' },
        default = { ['type'] = 'enemysimple', attr = { '1', '10', 'self.x,self.y', '0', '0', '0', '1', 'false', 'false', 'false' } },
        totext = function(nodedata)
            return string.format("create enemy in (%s)", nodedata.attr[3])
        end,
        tohead = function(nodedata)
            return string.format("last=New(EnemySimple, %s, %s, %s, {%s, %s, %s}, %s, %s, %s, %s, function(self)\n",
                    unpack(nodedata.attr))
        end,
        tofoot = function()
            return "end)\n"
        end,
    },
    --lazer
    laserdefine = {
        { 'Type name', 'typename', CheckClassName },
        disptype = 'define laser',
        editfirst = true,
        allowparent = { 'root', 'folder' },
        allowchild = { 'callbackfunc' },
        totext = function(nodedata)
            return string.format("define laser type %q", nodedata.attr[1])
        end,
        depth = 0,
        watch = 'laserdefine',
        default = {
            ["attr"] = {
                [1] = "",
            },
            ["type"] = "laserdefine",
            ["expand"] = true,
            ["child"] = {
                [1] = {
                    ["attr"] = { '', 'COLOR_RED', '64', '32', '64', '8', '0', '0' },
                    ["type"] = "laserinit",
                    ["expand"] = true,
                    ["child"] = {
                        [1] = {
                            ["attr"] = {
                            },
                            ["type"] = "task",
                            ["expand"] = true,
                            ["child"] = {
                                [1] = { ['type'] = 'laserturnon', attr = { '30', 'true', 'true' } },
                            },
                        },
                    },
                },
            },
        },
        tohead = function(nodedata)
            className = nodedata.attr[1]
            difficulty = string.match(nodedata.attr[1], '^.+:(.+)$')
            return string.format("_editor_class[%q]=Class(laser)\n", className)
        end,
        tofoot = function()
            difficulty = nil
            return ''
        end,
        check = function(nodedata)
            difficulty = string.match(nodedata.attr[1], '^.+:(.+)$')
        end,
        checkafter = function()
            difficulty = nil
        end,
    },
    laserinit = {
        { 'Parameter list', 'any', CheckParam },
        { 'Color', 'color', CheckExpr },
        { 'Head length', 'any', CheckExpr },
        { 'Body length', 'any', CheckExpr },
        { 'Tail length', 'any', CheckExpr },
        { 'Width', 'any', CheckExpr },
        { 'Node size', 'any', CheckExpr },
        { 'Head', 'any', CheckExpr },
        disptype = 'on create laser',
        allowparent = {},
        forbiddelete = true,
        totext = function(nodedata)
            return string.format("on create: (%s)", nodedata.attr[1])
        end,
        tohead = function(nodedata)
            local p
            if IsBlank(nodedata.attr[1]) then
                p = '_'
            else
                p = nodedata.attr[1]
            end
            return string.format("_editor_class[%q].init=function(self,_x,_y,%s)\
	laser.init(self,%s,_x,_y,0,%s,%s,%s,%s,%s,%s)\
", className, p, nodedata.attr[2], nodedata.attr[3], nodedata.attr[4], nodedata.attr[5], nodedata.attr[6], nodedata.attr[7], nodedata.attr[8])
        end,
        tofoot = function()
            return "end\n"
        end,
    },
    lasercreate = {
        { 'Type name', 'selecttype', CheckNonBlank },
        { 'Position', 'any', CheckPos },
        { 'Parameter', 'param', CheckExprOmit },
        disptype = 'create laser',
        editfirst = true,
        default = { ["type"] = 'lasercreate', attr = { '', 'self.x,self.y', '' } },
        forbidparent = { 'root', 'folder' },
        allowchild = {},
        totext = function(nodedata)
            return string.format("create laser of type %q with parameter %s", nodedata.attr[1], nodedata.attr[3])
        end,
        tohead = function(nodedata)
            local p
            if IsBlank(nodedata.attr[3]) then
                p = "_"
            else
                p = nodedata.attr[3]
            end
            return string.format("last=New(_editor_class[%q],%s,%s)\n", nodedata.fullclassname, nodedata.attr[2], p)
        end,
        check = function(nodedata)
            local class
            if difficulty and watchDict.laserdefine[nodedata.attr[1] .. ':' .. difficulty] then
                class = nodedata.attr[1] .. ':' .. difficulty
            elseif watchDict.laserdefine[nodedata.attr[1]] then
                class = nodedata.attr[1]
            else
                return string.format('laser type %q does not exist', nodedata.attr[1])
            end
            if paramNumDict[class] ~= CalcParamNum(nodedata.attr[3]) then
                return "number of parameter is incorrect"
            end
            nodedata.fullclassname = class
        end,
    },
    laserturnon = {
        { 'time (in frames)', 'any', CheckExpr },
        { 'Play sound effect', 'bool', CheckExpr },
        { 'wait in this task', 'bool', CheckExpr },
        disptype = 'turn on laser',
        needancestor = { 'laserdefine', 'lasershooter', 'taskdefine', 'laserbentdefine' },
        default = { ['type'] = 'laserturnon', attr = { '30', 'true' } },
        totext = function(nodedata)
            return string.format("turn on in %s frame(s)", nodedata.attr[1])
        end,
        tohead = function(nodedata)
            return string.format("laser._TurnOn(self,%s,%s,%s)\n", nodedata.attr[1], nodedata.attr[2], nodedata.attr[3])
        end,
        allowchild = {},
    },
    laserturnoff = {
        { 'time (in frames)', 'any', CheckExpr },
        { 'wait in this task', 'bool', CheckExpr },
        disptype = 'turn off laser',
        needancestor = { 'laserdefine', 'lasershooter', 'taskdefine', 'laserbentdefine' },
        default = { ['type'] = 'laserturnoff', attr = { '30' } },
        totext = function(nodedata)
            return string.format("turn off in %s frame(s)", nodedata.attr[1])
        end,
        tohead = function(nodedata)
            return string.format("laser._TurnOff(self,%s,%s)\n", nodedata.attr[1], nodedata.attr[2])
        end,
        allowchild = {},
    },
    laserturnhalfon = {
        { 'time (in frames)', 'any', CheckExpr },
        { 'wait in this task', 'bool', CheckExpr },
        disptype = 'turn half on laser',
        needancestor = { 'laserdefine', 'lasershooter', 'taskdefine', 'laserbentdefine' },
        default = { ['type'] = 'laserturnhalfon', attr = { '30' } },
        totext = function(nodedata)
            return string.format("turn half on in %s frame(s)", nodedata.attr[1])
        end,
        tohead = function(nodedata)
            return string.format("laser._TurnHalfOn(self,%s,%s)\n", nodedata.attr[1], nodedata.attr[2])
        end,
        allowchild = {},
    },
    lasergrow = {
        { 'time (in frames)', 'any', CheckExpr },
        { 'Play sound effect', 'bool', CheckExpr },
        { 'wait in this task', 'bool', CheckExpr },
        disptype = 'grow laser',
        needancestor = { 'laserdefine', 'lasershooter' },
        default = { ['type'] = 'lasergrow', attr = { '30', 'true' } },
        totext = function(nodedata)
            return string.format("grow in %s frame(s)", nodedata.attr[1])
        end,
        tohead = function(nodedata)
            return string.format("laser.grow(self,%s,%s,%s)\n", nodedata.attr[1], nodedata.attr[2], nodedata.attr[3])
        end,
        allowchild = {},
    },
    laserchange = {
        { 'Laser', 'any', CheckExpr },
        { 'Image', 'any', CheckExpr },
        { 'Color', 'color', CheckExpr },
        disptype = 'change laser\'s image and color',
        forbidparent = { 'folder', 'root' },
        allowchild = {},
        default = { ['type'] = 'laserchange', attr = { 'self', '1', 'orginal' } },
        totext = function(nodedata)
            return string.format("set %s's style to laser%s and color to %s", nodedata.attr[1], nodedata.attr[2], nodedata.attr[3])
        end,
        tohead = function(nodedata)
            local ret
            if nodedata.attr[3] == 'original' then
                ret = ""
            else
                ret = "," .. nodedata.attr[3]
            end
            return string.format("laser.ChangeImage(%s,%s%s)\n", nodedata.attr[1], nodedata.attr[2], ret)
        end,
    },
    --bent lazer
    laserbentdefine = {
        { 'Type name', 'typename', CheckClassName },
        disptype = 'define bent laser',
        editfirst = true,
        allowparent = { 'root', 'folder' },
        allowchild = { 'callbackfunc' },
        totext = function(nodedata)
            return string.format("define bent laser type %q", nodedata.attr[1])
        end,
        depth = 0,
        watch = 'laserbentdefine',
        default = {
            ["attr"] = {
                [1] = "",
            },
            ["type"] = "laserbentdefine",
            ["expand"] = true,
            ["child"] = {
                [1] = {
                    ["attr"] = { '', 'COLOR_RED', '32', '8', '4', '0' },
                    ["type"] = "laserbentinit",
                    ["expand"] = true,
                    ["child"] = {
                        [1] = {
                            ["attr"] = {},
                            ["type"] = "task",
                        },
                    },
                },
            },
        },
        tohead = function(nodedata)
            className = nodedata.attr[1]
            difficulty = string.match(nodedata.attr[1], '^.+:(.+)$')
            return string.format("_editor_class[%q]=Class(laser_bent)\n", className)
        end,
        tofoot = function()
            difficulty = nil
            return ''
        end,
        check = function(nodedata)
            difficulty = string.match(nodedata.attr[1], '^.+:(.+)$')
        end,
        checkafter = function()
            difficulty = nil
        end,
    },
    laserbentinit = {
        { 'Parameter list', 'any', CheckParam },
        { 'Color', 'color', CheckExpr },
        { 'Length (in frames)', 'any', CheckExpr },
        { 'Width', 'any', CheckExpr },
        { 'Sampling', 'any', CheckExpr },
        { 'Node', 'any', CheckExpr },
        disptype = 'on create bent laser',
        allowparent = {},
        forbiddelete = true,
        totext = function(nodedata)
            return string.format("on create: (%s)", nodedata.attr[1])
        end,
        tohead = function(nodedata)
            local p
            if IsBlank(nodedata.attr[1]) then
                p = '_'
            else
                p = nodedata.attr[1]
            end
            return string.format("_editor_class[%q].init=function(self,_x,_y,%s)\
	laser_bent.init(self,%s,_x,_y,%s,%s,%s,%s)\
", className, p, nodedata.attr[2], nodedata.attr[3], nodedata.attr[4], nodedata.attr[5], nodedata.attr[6])
        end,
        tofoot = function()
            return "end\n"
        end,
    },
    laserbentcreate = {
        { 'Type name', 'selecttype', CheckNonBlank },
        { 'Position', 'any', CheckPos },
        { 'Parameter', 'param', CheckExprOmit },
        disptype = 'create bent laser',
        editfirst = true,
        default = { ["type"] = 'laserbentcreate', attr = { '', 'self.x,self.y', '' } },
        forbidparent = { 'root', 'folder' },
        allowchild = {},
        totext = function(nodedata)
            return string.format("create bent laser of type %q with parameter %s", nodedata.attr[1], nodedata.attr[3])
        end,
        tohead = function(nodedata)
            local p
            if IsBlank(nodedata.attr[3]) then
                p = "_"
            else
                p = nodedata.attr[3]
            end
            return string.format("last=New(_editor_class[%q],%s,%s)\n", nodedata.fullclassname, nodedata.attr[2], p)
        end,
        check = function(nodedata)
            local class
            if difficulty and watchDict.laserbentdefine[nodedata.attr[1] .. ':' .. difficulty] then
                class = nodedata.attr[1] .. ':' .. difficulty
            elseif watchDict.laserbentdefine[nodedata.attr[1]] then
                class = nodedata.attr[1]
            else
                return string.format('bent laser type %q does not exist', nodedata.attr[1])
            end
            if paramNumDict[class] ~= CalcParamNum(nodedata.attr[3]) then
                return "number of parameter is incorrect"
            end
            nodedata.fullclassname = class
        end,
    },
    --bullet
    bulletdefine = {
        { 'Type name', 'typename', CheckClassName },
        disptype = 'define bullet',
        editfirst = true,
        allowparent = { 'root', 'folder' },
        allowchild = { 'callbackfunc' },
        totext = function(nodedata)
            return string.format("define bullet type %q", nodedata.attr[1])
        end,
        depth = 0,
        watch = 'bulletdefine',
        default = {
            ["attr"] = { "" },
            ["type"] = "bulletdefine",
            ["expand"] = true,
            ["child"] = {
                [1] = {
                    ["attr"] = { "", "arrow_big", "COLOR_RED", "true", "true" },
                    ["type"] = "bulletinit",
                },
            },
        },
        tohead = function(nodedata)
            className = nodedata.attr[1]
            difficulty = string.match(nodedata.attr[1], '^.+:(.+)$')
            return string.format("_editor_class[%q]=Class(bullet)\n", className)
        end,
        tofoot = function()
            difficulty = nil
            return ''
        end,
        check = function(nodedata)
            difficulty = string.match(nodedata.attr[1], '^.+:(.+)$')
        end,
        checkafter = function()
            difficulty = nil
        end,
    },
    bulletinit = {
        { 'Parameter list', 'any', CheckParam },
        { 'Style', 'bulletstyle', CheckExpr },
        { 'Color', 'color', CheckExpr },
        { 'Stay on create', 'bool', CheckExpr },
        { 'Destroyable', 'bool', CheckExpr },
        disptype = 'on create bullet',
        allowparent = {},
        forbiddelete = true,
        totext = function(nodedata)
            return string.format("on create: (%s)", nodedata.attr[1])
        end,
        tohead = function(nodedata)
            local p
            if IsBlank(nodedata.attr[1]) then
                p = "_"
            else
                p = nodedata.attr[1]
            end
            return string.format("_editor_class[%q].init=function(self,_x,_y,%s)\
	bullet.init(self,%s,%s,%s,%s)\
	self.x,self.y=_x,_y\
", className, p, nodedata.attr[2], nodedata.attr[3], nodedata.attr[4], nodedata.attr[5])
        end,
        tofoot = function()
            return "end\n"
        end,
    },
    bulletcreate = {
        { 'Type name', 'selecttype', CheckNonBlank },
        { 'Position', 'any', CheckPos },
        { 'Parameter', 'param', CheckExprOmit },
        disptype = 'create bullet',
        editfirst = true,
        default = { ["type"] = 'bulletcreate', attr = { '', 'self.x,self.y', '' } },
        forbidparent = { 'root', 'folder' },
        allowchild = {},
        totext = function(nodedata)
            return string.format("create bullet of type %q at (%s) with parameter %s", nodedata.attr[1], nodedata.attr[2], nodedata.attr[3])
        end,
        tohead = function(nodedata)
            local p
            if IsBlank(nodedata.attr[3]) then
                p = "_"
            else
                p = nodedata.attr[3]
            end
            return string.format("last=New(_editor_class[%q],%s,%s)\n", nodedata.fullclassname, nodedata.attr[2], p)
        end,
        check = function(nodedata)
            local class
            if difficulty and watchDict.bulletdefine[nodedata.attr[1] .. ':' .. difficulty] then
                class = nodedata.attr[1] .. ':' .. difficulty
            elseif watchDict.bulletdefine[nodedata.attr[1]] then
                class = nodedata.attr[1]
            else
                return string.format('bullet type %q does not exist', nodedata.attr[1])
            end
            if paramNumDict[class] ~= CalcParamNum(nodedata.attr[3]) then
                return "number of parameter is incorrect"
            end
            nodedata.fullclassname = class
        end,
    },
    bulletchangestyle = {
        { 'Bullet', 'target', CheckExpr },
        { 'Style', 'bulletstyle', CheckExpr },
        { 'Color', 'color', CheckExpr },
        disptype = 'change bullet\'s style and color',
        forbidparent = { 'folder', 'root' },
        allowchild = {},
        default = { ['type'] = 'bulletchangestyle', attr = { 'self', 'arrow_big', 'COLOR_RED' } },
        totext = function(nodedata)
            return string.format("set %s's style to %s and color to %s", nodedata.attr[1], nodedata.attr[2], nodedata.attr[3])
        end,
        tohead = function(nodedata)
            return string.format("ChangeBulletImage(%s,%s,%s)\n", nodedata.attr[1], nodedata.attr[2], nodedata.attr[3])
        end,
    },
    bulletcreatestraight = {
        { 'Style', 'bulletstyle', CheckExpr },
        { 'Color', 'color', CheckExpr },
        { 'Position', 'any', CheckPos },
        { 'Velocity', 'any', CheckExpr },
        { 'Angle', 'any', CheckExpr },
        { 'Aim to player', 'bool', CheckExpr },
        { 'Rotation Velocity', 'any', CheckExpr },
        { 'Stay on create', 'bool', CheckExpr },
        { 'Destroyable', 'bool', CheckExpr },
        { 'Time', 'any' },
        { 'Rebound', 'bool', CheckExpr },
        { 'Acceleration', 'any' },
        { 'Accel Angle', 'any' },
        { 'Max Velocity', 'any' },
        { 'Shuttle', 'bool', CheckExpr },
        disptype = 'create simple bullet',
        default = { ['type'] = 'bulletcreatestraight', attr = { 'arrow_big', 'COLOR_RED', 'self.x,self.y', '3', '0', 'false', '0', 'true', 'true', '0', 'false', '0', '0', '0', 'false' } },
        forbidparent = { 'root', 'folder' },
        allowchild = {},
        totext = function(nodedata)
            local ret = string.format("create simple bullet %s,%s at (%s)   v=%s,angle=%s", nodedata.attr[1], nodedata.attr[2], nodedata.attr[3], nodedata.attr[4], nodedata.attr[5])
            if nodedata.attr[6] == 'true' then
                ret = ret .. ", aim to player"
            end
            if #nodedata.attr[10] ~= 0 and nodedata.attr[10] ~= '0' then
                ret = ret .. ", after " .. nodedata.attr[10] .. " frames"
            end
            if nodedata.attr[15] == 'true' then
                ret = ret .. ", break through the screen"
            end
            if nodedata.attr[11] == 'true' then
                ret = ret .. ", rebound when touching the wall"
            end
            return ret
        end,
        tohead = function(nodedata)
            if #nodedata.attr[10] == 0 then
                nodedata.attr[10] = '0'
            end
            if #nodedata.attr[12] == 0 then
                nodedata.attr[12] = '0'
            end
            if #nodedata.attr[13] == 0 then
                nodedata.attr[13] = '0'
            end
            if #nodedata.attr[14] == 0 then
                nodedata.attr[14] = '0'
            end
            local aca = nodedata.attr[13]
            if nodedata.attr[13] == 'original' then
                aca = "'original'"
            end
            return string.format("last=New(_straight,%s,%s,%s,%s)\n",
                    table.concat(nodedata.attr, ",", 1, 12), aca, nodedata.attr[14], nodedata.attr[15])
        end,
    },
    bulletcreatestraightex = {
        { 'Style', 'bulletstyle', CheckExpr },
        { 'Color', 'color', CheckExpr },
        { 'Position', 'any', CheckPos },
        { 'Number', 'any', CheckExpr },
        { 'Interval (in frames)', 'any', CheckExpr },
        { 'Velocity start', 'any', CheckExpr },
        { 'Velocity end', 'any', CheckExpr },
        { 'Angle', 'any', CheckExpr },
        { 'Angle spread', 'any', CheckExpr },
        { 'Aim to player', 'bool', CheckExpr },
        { 'Rotation Velocity', 'any', CheckExpr },
        { 'Stay on create', 'bool', CheckExpr },
        { 'Destroyable', 'bool', CheckExpr },
        { 'Time', 'any' },
        { 'Rebound', 'bool', CheckExpr },
        disptype = 'create simple bullets',
        default = { ['type'] = 'bulletcreatestraightex', attr = { 'arrow_big', 'COLOR_RED', 'self.x,self.y', '5', '0', '3', '4', '0', '0', 'false', '0', 'true', 'true', '0', 'false' } },
        forbidparent = { 'root', 'folder' },
        allowchild = {},
        totext = function(nodedata)
            local attr = nodedata.attr
            local ret = string.format("create %s simple bullet(s) %s,%s at (%s)   interval=%s,v=%s~%s,angle=%s,spread=%s", attr[4], attr[1], attr[2], attr[3], attr[5], attr[6], attr[7], attr[8], attr[9])
            if attr[10] == 'true' then
                ret = ret .. ", aim to player"
            end
            if #nodedata.attr[14] ~= 0 and nodedata.attr[14] ~= '0' then
                ret = ret .. ", after " .. nodedata.attr[14] .. " frames"
            end
            if nodedata.attr[15] == 'true' then
                ret = ret .. ", rebound when touching the wall"
            end
            return ret
        end,
        tohead = function(nodedata)
            if #nodedata.attr[14] == 0 then
                nodedata.attr[14] = '0'
            end
            return string.format("_create_bullet_group(%s,self)\n", table.concat(nodedata.attr, ","))
        end,
    },
    bulletclear = {
        { 'Convert to faith', 'bool', CheckExpr },
        { 'Clear indestructible', 'bool', CheckExpr },
        disptype = 'clear bullet',
        default = { ["type"] = 'bulletclear', attr = { 'true', 'false' } },
        forbidparent = { 'root', 'folder' },
        allowchild = {},
        totext = function()
            return "clear all bullets"
        end,
        tohead = function(nodedata)
            return string.format("_clear_bullet(%s,%s)\n", nodedata.attr[1], nodedata.attr[2])
        end,
    },
    bulletcleanrange = {
        { 'Position', 'any', CheckPos },
        { 'Radius of Range', 'any', CheckExpr },
        { 'Time of Spreading out', 'any', CheckExpr },
        { 'Duration', 'any', CheckExpr },
        { 'Convert bullet into faith', 'bool', CheckExpr },
        { 'Clean the indestroyable bullet', 'bool', CheckExpr },
        { 'floating velocity', 'any', CheckExpr },
        disptype = 'make a floating bullet-cleaning range',
        forbidparent = { 'root', 'folder' },
        allowchild = {},
        default = { ['type'] = 'bulletcleanrange', ['attr'] = { 'player.x,player.y', '48', '15', '45', 'true', 'true', '0' } },
        totext = function(nodedata)
            return string.format('make a floating(v=%s) bullet-cleaning range(%s) in (%s), last (%s+%s) frames.',
                    nodedata.attr[7], nodedata.attr[2], nodedata.attr[1], nodedata.attr[3], nodedata.attr[4])
        end,
        tohead = function(nodedata)
            return string.format('New(bullet_cleaner,%s)\n', table.concat(nodedata.attr, ", "))
        end
    },
    --object
    objectdefine = {
        { 'Type name', 'typename', CheckClassName },
        disptype = 'define object',
        editfirst = true,
        allowparent = { 'root', 'folder' },
        allowchild = { 'callbackfunc' },
        totext = function(nodedata)
            return string.format("define object type %q", nodedata.attr[1])
        end,
        depth = 0,
        watch = 'objectdefine',
        default = {
            ["attr"] = {
                [1] = "",
            },
            ["type"] = "objectdefine",
            ["expand"] = true,
            ["child"] = {
                [1] = {
                    ["attr"] = { '', 'leaf', 'LAYER_ENEMY_BULLET', 'GROUP_ENEMY_BULLET', 'false', 'true', 'false', '10', 'true' },
                    ["type"] = "objectinit",
                    ["expand"] = true,
                    ["child"] = {
                        [1] = {
                            ["attr"] = {
                            },
                            ["type"] = "task",
                            ["child"] = {
                            },
                        },
                    },
                },
            },
        },
        tohead = function(nodedata)
            className = nodedata.attr[1]
            difficulty = string.match(nodedata.attr[1], '^.+:(.+)$')
            return string.format("_editor_class[%q]=Class(_object)\n", className)
        end,
        tofoot = function()
            difficulty = nil
            return ''
        end,
        check = function(nodedata)
            difficulty = string.match(nodedata.attr[1], '^.+:(.+)$')
        end,
        checkafter = function()
            difficulty = nil
        end,
    },
    objectinit = {
        { 'Parameter list', 'any', CheckParam },
        { 'Image', 'image', CheckNonBlank },
        { 'Layer', 'layer', CheckExpr },
        { 'Group', 'group', CheckExpr },
        { 'Hide', 'bool', CheckExpr },
        { 'Bound', 'bool', CheckExpr },
        { 'Auto rotation', 'bool', CheckExpr },
        { 'Hit point', 'any', CheckExpr },
        { 'Collision', 'bool', CheckExpr },
        disptype = 'on create object',
        allowparent = {},
        forbiddelete = true,
        totext = function(nodedata)
            return string.format("on create: (%s)", nodedata.attr[1])
        end,
        tohead = function(nodedata)
            local p
            if IsBlank(nodedata.attr[1]) then
                p = "_"
            else
                p = nodedata.attr[1]
            end
            return string.format("_editor_class[%q].init=function(self,_x,_y,%s)\
	self.x,self.y=_x,_y\
	self.img=%q\
	self.layer=%s\
	self.group=%s\
	self.hide=%s\
	self.bound=%s\
	self.navi=%s\
	self.hp=%s\
	self.maxhp=%s\
	self.colli=%s\
	self._servants={}\
	self._blend,self._a,self._r,self._g,self._b='',255,255,255,255\
", className, p, nodedata.attr[2], nodedata.attr[3], nodedata.attr[4], nodedata.attr[5], nodedata.attr[6], nodedata.attr[7], nodedata.attr[8], nodedata.attr[8], nodedata.attr[9])
        end,
        tofoot = function()
            return "end\n"
        end,
        --[[check=function(nodedata)
			if not (watchDict.image[nodedata.attr[2] ] or nodedata.attr[2]=='leaf') then return string.format('image %q does not exist',nodedata.attr[2]) end
		end,--]]
    },
    objectcreate = {
        { 'Type name', 'selecttype', CheckNonBlank },
        { 'Position', 'any', CheckPos },
        { 'Parameter', 'param', CheckExprOmit },
        disptype = 'create object',
        editfirst = true,
        default = { ["type"] = 'objectcreate', attr = { '', 'self.x,self.y', '' } },
        forbidparent = { 'root', 'folder' },
        allowchild = {},
        totext = function(nodedata)
            return string.format("create object of type %q at (%s) with parameter %s", nodedata.attr[1], nodedata.attr[2], nodedata.attr[3])
        end,
        tohead = function(nodedata)
            local p
            if IsBlank(nodedata.attr[3]) then
                p = "_"
            else
                p = nodedata.attr[3]
            end
            return string.format("last=New(_editor_class[%q],%s,%s)\n", nodedata.fullclassname, nodedata.attr[2], p)
        end,
        check = function(nodedata)
            local class
            if difficulty and watchDict.objectdefine[nodedata.attr[1] .. ':' .. difficulty] then
                class = nodedata.attr[1] .. ':' .. difficulty
            elseif watchDict.objectdefine[nodedata.attr[1]] then
                class = nodedata.attr[1]
            else
                return string.format('object type %q does not exist', nodedata.attr[1])
            end
            if paramNumDict[class] ~= CalcParamNum(nodedata.attr[3]) then
                return "number of parameter is incorrect"
            end
            nodedata.fullclassname = class
        end,
    },
    renderimage = {
        { 'image', 'any', CheckNonBlank },
        { 'Position', 'any', CheckPos },
        { 'Rotation', 'any', CheckExpr },
        { 'Horizonal scale', 'any', CheckExpr },
        { 'Vertical scale', 'any', CheckExpr },
        { 'Layer', 'layer', CheckExpr },
        disptype = 'create simple object with task',
        default = { ["type"] = 'renderimage', attr = { '"leaf"', 'self.x,self.y', '0', '1.0', '1.0', 'LAYER_BG' } },
        forbidparent = { 'root', 'folder' },
        allowchild = { 'task' },
        totext = function(nodedata)
            return 'draw ' .. nodedata.attr[1] .. ' in (' .. nodedata.attr[2] .. ')'
        end,
        tohead = function(nodedata)
            return string.format("last=New(RenderObject,self,%s,function(self)\n", table.concat(nodedata.attr, ","))
        end,
        tofoot = function()
            return "end)\n"
        end
    },
    --boss
    bossdefine = {
        { 'Type name', 'typename', CheckClassName },
        { 'Displayed name', 'any', CheckNonBlank },
        { 'Position', 'any', CheckPos },
        { 'Spell Card Background', 'selecttype' },
        { 'Image', 'resfile' },
        { 'nCol', 'any', CheckExpr },
        { 'nRow', 'any', CheckExpr },
        { 'Collision size', 'any', CheckExpr },
        { 'Animation interval', 'any', CheckExpr },
        { "Background", "any" },
        { "Background Music", "any" },
        { 'Number of imgs', 'any' },
        { 'Number of anis', 'any' },
        disptype = 'define boss',
        editfirst = true,
        default = {
            ["attr"] = { "", "Name", "240,384", "", "", "4", "3", "16,16", "8", "", "", "4,4,4,4", "1,1,1" },
            ["type"] = "bossdefine",
            expand = true,
            ["child"] = {
                [1] = {
                    ["attr"] = { "0,144", "60", "MOVE_NORMAL", },
                    ["type"] = "bossmoveto",
                },
                [2] = {
                    ["attr"] = { "", "2", "15", "60", "600", "0", "0", "0", "false" },
                    ["type"] = "bossspellcard",
                    ["expand"] = true,
                    ["child"] = {
                        [1] = {
                            ["attr"] = {},
                            ["type"] = "bossscbefore",
                            ["expand"] = true,
                            ["child"] = {
                                [1] = {
                                    ["attr"] = { '0,144', '60', 'MOVE_NORMAL' },
                                    ["type"] = "taskmoveto",
                                },
                            },
                        },
                        [2] = {
                            ["attr"] = {},
                            ["type"] = "bossscstart",
                            ["expand"] = true,
                            ["child"] = {
                                [1] = {
                                    ["attr"] = {
                                    },
                                    ["type"] = "task",
                                    ["expand"] = true,
                                    ["child"] = {
                                    },
                                },
                            },
                        },
                        [3] = {
                            ["attr"] = {},
                            ["type"] = "bossscfinish",
                        },
                    },
                },
            },
        },
        allowparent = { 'root', 'folder' },
        allowchild = { 'bossspellcard', 'bossmoveto', 'dialog' },
        watch = 'bossdefine',
        totext = function(nodedata)
            return string.format("define boss %q", nodedata.attr[1])
        end,
        depth = 0,
        tohead = function(nodedata)
            className = nodedata.attr[1]
            difficulty = string.match(nodedata.attr[1], '^.+:(.+)$')
            if difficulty == nil or difficulty == '' then
                difficulty = 'All'
            end
            local scbg, _bg, bgm
            if IsBlank(nodedata.attr[10]) then
                _bg = 'nil'
            else
                _bg = nodedata.attr[10]
            end
            if IsBlank(nodedata.attr[4]) then
                scbg = "spellcard_background"
            else
                scbg = string.format("_editor_class[%q]", nodedata.attr[4])
            end
            if IsBlank(nodedata.attr[11]) then
                bgm = 'nil'
            else
                bgm = nodedata.attr[11]
            end
            if IsBlank(nodedata.attr[5]) then
                return string.format(
                        "_editor_class[%q]=boss.define(%q,%q,%s,%s,%q,%s,%s)\n",
                        className, className, nodedata.attr[2], nodedata.attr[3], scbg, --className, id, name, pos(x, y), scbg
                        difficulty, bgm, _bg) --difficulty, bgm, bg
            else
                local fn = wx.wxFileName(nodedata.attr[5]):GetFullName()
                return string.format(
                        "_editor_class[%q]=boss.define(%q,%q,%s,%s,%q,%s,%s,%q,%s,%s,%s,%s,{%s},{%s})\n",
                        className, className, nodedata.attr[2], nodedata.attr[3], scbg, --className, id, name, pos(x, y), scbg
                        difficulty, bgm, _bg, --difficulty, bgm, bg
                        fn, nodedata.attr[6], nodedata.attr[7], nodedata.attr[8], --img, nCol, nRow, colli(a, b)
                        nodedata.attr[9], nodedata.attr[12], nodedata.attr[13]) --intv, imgs, anis
            end
        end,
        tofoot = function()
            difficulty = nil
            return ''
        end,
        check = function(nodedata)
            if not IsBlank(nodedata.attr[5]) then
                local absfn = MakeFullPath(nodedata.attr[5])
                if not wx.wxFileName(absfn):FileExists() then
                    return string.format("Resource file %q does not exist", absfn)
                end
                local fn = wx.wxFileName(nodedata.attr[5]):GetFullName()
                if not CheckAnonymous(fn, absfn) then
                    return string.format("Repeated resource file name %q", fn)
                end
                local f, msg = io.open("editor\\tmp\\_pack_res.bat", "a")
                if msg then
                    return msg
                end
                f:write(string.format('..\\tools\\7z\\7z u -tzip -mcu=on "..\\game\\mod\\%s.zip" "%s"\n', outputName, absfn))
                f:close()
            end
            if nodedata.attr[4] ~= '' and (not watchDict.bgdefine[nodedata.attr[4]]) then
                return string.format('background type %q does not exist', nodedata.attr[4])
            end
            difficulty = string.match(nodedata.attr[1], '^.+:(.+)$')
        end,
        checkafter = function()
            difficulty = nil
        end,
    },
    bossspellcard = {
        { 'Name', 'any' },
        { 'Protect time (seconds)', 'any', CheckExpr },
        { 'Full damage time (seconds)', 'any', CheckExpr },
        { 'Total time (seconds)', 'any', CheckExpr },
        { 'Hit point', 'any', CheckExpr },
        { 'Drop power', 'any', CheckExpr },
        { 'Drop faith', 'any', CheckExpr },
        { 'Drop point', 'any', CheckExpr },
        { 'Immune to bomb', 'bool', CheckExpr },
        { 'Performing action', 'bool', CheckExpr },
        { 'Optional ID', 'any' },
        disptype = 'spell card',
        default = {
            ["attr"] = { "", "2", "15", "60", "600", "0", "0", "0", "false", "false", "" },
            ["type"] = "bossspellcard",
            ["expand"] = true,
            ["child"] = {
                [1] = {
                    ["attr"] = {},
                    ["type"] = "bossscbefore",
                    ["expand"] = true,
                    ["child"] = {
                        [1] = {
                            ["attr"] = { '0,144', '60', 'MOVE_NORMAL' },
                            ["type"] = "taskmoveto",
                        },
                    },
                },
                [2] = {
                    ["attr"] = {},
                    ["type"] = "bossscstart",
                    ["expand"] = true,
                    ["child"] = {
                        [1] = {
                            ["attr"] = {
                            },
                            ["type"] = "task",
                            ["expand"] = true,
                            ["child"] = {
                            },
                        },
                    },
                },
                [3] = {
                    ["attr"] = {},
                    ["type"] = "bossscfinish",
                },
            },
        },
        depth = 0,
        allowchild = {},
        allowparent = { 'bossdefine' },
        totext = function(nodedata)
            local a = ''
            if not IsBlank(nodedata.attr[11]) then
                a = " ( ID : " .. '"' .. nodedata.attr[11] .. '"' .. ")"
            end

            if IsBlank(nodedata.attr[1]) then
                return "non-spell card" .. a
            else
                return string.format("spell card %q", nodedata.attr[1]) .. a
            end
        end,
        tohead = function(nodedata)
            return string.format("_tmp_sc=boss.card.New(%q,%s,%s,%s,%s,{%s,%s,%s},%s)\n"
            , nodedata.attr[1], nodedata.attr[2], nodedata.attr[3], nodedata.attr[4], nodedata.attr[5], nodedata.attr[6], nodedata.attr[7], nodedata.attr[8], nodedata.attr[9])
        end,
        tofoot = function(nodedata)
            local perform = tostring(toboolean(nodedata.attr[10]))
            local a = ''
            if not IsBlank(nodedata.attr[11]) then
                a = "_editor_cards." .. nodedata.attr[11] .. "=_tmp_sc\n"
            end
            a = a .. string.format("_tmp_sc.perform=%s\n", perform)
            if IsBlank(nodedata.attr[1]) then
                return a .. string.format("table.insert(_editor_class[%q].cards,_tmp_sc)\n", className)
            else
                return a .. string.format("table.insert(_editor_class[%q].cards,_tmp_sc)\ntable.insert(_sc_table,{%q,%q,_tmp_sc,#_editor_class[%q].cards,%s})\n", className, className, nodedata.attr[1], className, perform)
            end
        end
    },
    bossspellcardex = {
        { 'ID', 'any' },
        { 'Name', 'any' },
        { 'Protect time (seconds)', 'any', CheckExpr },
        { 'Full damage time (seconds)', 'any', CheckExpr },
        { 'Total time (seconds)', 'any', CheckExpr },
        { 'Hit point', 'any', CheckExpr },
        { 'Drop power', 'any', CheckExpr },
        { 'Drop faith', 'any', CheckExpr },
        { 'Drop point', 'any', CheckExpr },
        { 'Immune to bomb', 'bool', CheckExpr },
        { 'Performing action', 'bool', CheckExpr },
        { 'Fake spell card', 'bool', CheckExpr },
        disptype = 'spell card ex',
        watch = 'carddefine',
        default = {
            ["attr"] = { "", "", "2", "15", "60", "600", "0", "0", "0", "false", "false", "false" },
            ["type"] = "bossspellcardex",
            ["expand"] = true,
            ["child"] = {
                [1] = {
                    ["attr"] = {},
                    ["type"] = "bossscbefore",
                    ["expand"] = true,
                    ["child"] = {
                        [1] = {
                            ["attr"] = { '0,144', '60', 'MOVE_NORMAL' },
                            ["type"] = "taskmoveto",
                        },
                    },
                },
                [2] = {
                    ["attr"] = {},
                    ["type"] = "bossscstart",
                    ["expand"] = true,
                    ["child"] = {
                        [1] = {
                            ["attr"] = {
                            },
                            ["type"] = "task",
                        },
                    },
                },
                [3] = {
                    ["attr"] = {},
                    ["type"] = "bossscfinish",
                },
            },
        },
        depth = 0,
        allowchild = {},
        allowparent = { 'root', 'folder' },
        totext = function(nodedata)
            if IsBlank(nodedata.attr[2]) then
                if nodedata.attr[12] == 'true' then
                    return string.format("fake spell card id %q", nodedata.attr[1])

                else
                    return string.format("non spell card id %q", nodedata.attr[1])
                end
            else
                return string.format("spell card id %q : %q", nodedata.attr[1], nodedata.attr[2])
            end
        end,
        tohead = function(nodedata)
            return string.format("_tmp_sc=boss.card.New(%q,%s,%s,%s,%s,{%s,%s,%s},%s)\n"
            , nodedata.attr[2], nodedata.attr[3], nodedata.attr[4], nodedata.attr[5], nodedata.attr[6], nodedata.attr[7], nodedata.attr[8], nodedata.attr[9], nodedata.attr[10])
        end,
        tofoot = function(nodedata)
            return string.format("_editor_cards[%q]=_tmp_sc\n_tmp_sc.fake=%s\n", nodedata.attr[1], nodedata.attr[12])
        end
    },
    bossscbefore = {
        allowparent = { 'bossspellcard' },
        disptype = 'task before spell card',
        forbiddelete = true,
        totext = function()
            return "task before start"
        end,
        tohead = function()
            return "function _tmp_sc:before()\n"
        end,
        tofoot = function()
            return "end\n"
        end,
    },
    bossscstart = {
        allowparent = { 'bossspellcard' },
        disptype = 'on start spell card',
        forbiddelete = true,
        totext = function()
            return "on start"
        end,
        tohead = function()
            return "function _tmp_sc:init()\n"
        end,
        tofoot = function()
            return "end\n"
        end,
    },
    bossscfinish = {
        allowparent = { 'bossspellcard' },
        disptype = 'on finish spell card',
        forbiddelete = true,
        totext = function()
            return "on finish"
        end,
        tohead = function()
            return "function _tmp_sc:del()\n"
        end,
        tofoot = function()
            return "end\n"
        end,
    },
    dialog = {
        { 'Can skip', 'bool', CheckExpr },
        { 'dialog', 'bool', CheckExpr },
        disptype = 'dialog',
        default = {
            ["attr"] = { "true", "true" },
            ["type"] = "dialog",
            ["expand"] = true,
            ["child"] = { { ["type"] = 'dialogtask', attr = {} } }
        },
        allowchild = {},
        allowparent = { 'bossdefine' },
        totext = function()
            return "dialog"
        end,
        tohead = function(nodedata)
            return string.format("_tmp_sc=boss.dialog.New(%s)\nfunction _tmp_sc:init()\n\tlstg.player.dialog=%s\n\t_dialog_can_skip=%s\n\tself.dialog_displayer=New(dialog_displayer)\n", nodedata.attr[1], nodedata.attr[2], nodedata.attr[1])
        end,
        tofoot = function()
            return string.format("end\ntable.insert(_editor_class[%q].cards,_tmp_sc)\n", className)
        end
    },
    dialogtask = {
        disptype = 'task for dialog',
        allowparent = {},
        forbiddelete = true,
        totext = function()
            return "create task"
        end,
        tohead = function()
            return "task.New(self,function()\n"
        end,
        tofoot = function()
            return "end)\n"
        end,
    },
    sentence = {
        { 'Image', 'image', CheckNonBlank },
        { 'Position', 'leftright', CheckNonBlank },
        { 'Text', 'any' },
        { 'Time (in frames)', 'any', CheckExprOmit },
        { 'Scale', 'any', CheckExprOmit },
        editfirst = true,
        disptype = 'sentence',
        needancestor = { 'dialogtask' },
        allowchild = {},
        totext = function(nodedata)
            return string.format("%s %s %q", nodedata.attr[1], nodedata.attr[2], nodedata.attr[3])
        end,
        tohead = function(nodedata)
            local t = nodedata.attr[4]
            local s = nodedata.attr[5]
            if t == "" then
                t = "nil"
            end
            if s == '' then
                return string.format("boss.dialog.sentence(self,%q,%q,%q,%s)\n", nodedata.attr[1], nodedata.attr[2], nodedata.attr[3], t)

            else
                return string.format("boss.dialog.sentence(self,%q,%q,%q,%s,%s)\n", nodedata.attr[1], nodedata.attr[2], nodedata.attr[3], t, nodedata.attr[5])
            end
        end,
    },
    bosscreate = {
        { 'Type name', 'selecttype', CheckNonBlank },
        { 'Wait', 'bool', CheckExpr },
        disptype = 'create boss',
        editfirst = true,
        needancestor = { 'stage', 'bossexdefine' },
        allowchild = {},
        totext = function(nodedata)
            return string.format("create boss %q", nodedata.attr[1])
        end,
        tohead = function(nodedata)
            return string.format("local _boss_wait=%s\
local _ref=boss.createWithCards(%q,_editor_class[%q].cards)\
last=_ref\
if _boss_wait then\
    while IsValid(_ref) do\
        task.Wait()\
    end\
end\n", nodedata.attr[2], nodedata.fullclassname, nodedata.fullclassname)
        end,
        check = function(nodedata)
            local class
            if difficulty and watchDict.bossdefine[nodedata.attr[1] .. ':' .. difficulty] then
                class = nodedata.attr[1] .. ':' .. difficulty
            elseif watchDict.bossdefine[nodedata.attr[1]] then
                class = nodedata.attr[1]
            else
                return string.format('boss type %q does not exist', nodedata.attr[1])
            end
            nodedata.fullclassname = class
        end,
    },
    bossmoveto = {
        { 'Destination', 'any', CheckExpr },
        { 'nFrame', 'any', CheckExprOmit },
        { 'Mode', 'movetomode', CheckExprOmit },
        disptype = 'boss move to',
        allowparent = { 'bossdefine' },
        allowchild = {},
        default = { ["attr"] = { "0,144", "60", "MOVE_NORMAL" }, ["type"] = "bossmoveto" },
        totext = function(nodedata)
            local nf
            if IsBlank(nodedata.attr[2]) then
                nf = '1'
            else
                nf = nodedata.attr[2]
            end
            return "move to (" .. nodedata.attr[1] .. ") in " .. nf .. " frame(s)"
        end,
        tohead = function(nodedata)
            local nf, mode
            if IsBlank(nodedata.attr[2]) then
                nf = '1'
            else
                nf = nodedata.attr[2]
            end
            if IsBlank(nodedata.attr[3]) then
                mode = 'MOVE_NORMAL'
            else
                mode = nodedata.attr[3]
            end
            return string.format("table.insert(_editor_class[%q].cards,boss.move.New(%s,%s,%s))\n", className, nodedata.attr[1], nf, mode)
        end,
    },
    bosscast = {
        { 'Time', 'any', CheckExpr },
        needancestor = { 'bossdefine', 'bossexdefine', 'bossspellcardex' },
        disptype = 'boss cast',
        default = { ["attr"] = { '60' }, ["type"] = "bosscast" },
        allowchild = {},
        totext = function(nodedata)
            return string.format("play a cast animation in %s frame(s)", nodedata.attr[1])
        end,
        tohead = function(nodedata)
            return string.format("boss.cast(self,%s)\n", nodedata.attr[1])
        end,
    },
    bosssetui = {
        { 'Show hp circle', 'bool', CheckExpr },
        { 'Show boss name', 'bool', CheckExpr },
        { 'Show time counter', 'bool', CheckExpr },
        { 'Show spell name', 'bool', CheckExpr },
        { 'Need position', 'bool', CheckExpr },
        default = { ["attr"] = { 'true', 'true', 'true', 'true', 'true' }, ["type"] = "bosssetui" },
        disptype = 'show/hide boss ui objects',
        needancestor = { 'bossdefine', 'bossexdefine', 'bossspellcardex' },
        allowchild = {},
        totext = function()
            return "set boss ui display"
        end,
        tohead = function(nodedata)
            return string.format("boss.SetUIDisplay(self,%s,%s,%s,%s,%s)\n", nodedata.attr[1], nodedata.attr[2], nodedata.attr[3], nodedata.attr[4], nodedata.attr[5])
        end,
    },
    bossshowaura = {
        { 'Show aura', 'bool', CheckExpr },
        disptype = 'show/hide boss aura',
        needancestor = { 'bossdefine', 'bossexdefine', 'bossspellcardex' },
        allowchild = {},
        totext = function()
            return "show/hide aura"
        end,
        tohead = function(nodedata)
            return string.format("boss.show_aura(self,%s)\n", nodedata.attr[1])
        end,
    },
    bossexdefine = {
        { 'Type name', 'typename', CheckClassName },
        { 'Displayed name', 'any', CheckNonBlank },
        { 'Position', 'any', CheckPos },
        { 'Spell Card Background', 'selecttype' },
        { 'Image', 'resfile' },
        { 'nCol', 'any', CheckExpr },
        { 'nRow', 'any', CheckExpr },
        { 'Collision size', 'any', CheckExpr },
        { 'Animation interval', 'any', CheckExpr },
        { "Background", "any" },
        { "Background Music", "any" },
        { 'Number of imgs', 'any' },
        { 'Number of anis', 'any' },
        disptype = 'define boss ex',
        editfirst = true,
        default = {
            ["attr"] = { "", "Name", "240,384", "", "", "4", "3", "16,16", "8", "", "", "4,4,4,4", "1,1,1" },
            ["type"] = "bossexdefine",
            ["expand"] = true,
            ["child"] = { { ["type"] = 'task', attr = {} } }
        },
        allowparent = { 'root', 'folder' },
        allowchild = { 'task' },
        watch = 'bossdefine',
        totext = function(nodedata)
            return string.format("define boss %q", nodedata.attr[1])
        end,
        depth = 0,
        tohead = function(nodedata)
            className = nodedata.attr[1]
            difficulty = string.match(nodedata.attr[1], '^.+:(.+)$')
            if difficulty == nil or difficulty == '' then
                difficulty = 'All'
            end
            local scbg, _bg
            if IsBlank(nodedata.attr[10]) then
                _bg = 'nil'
            else
                _bg = nodedata.attr[10]
            end
            if IsBlank(nodedata.attr[4]) then
                scbg = "spellcard_background"
            else
                scbg = string.format("_editor_class[%q]", nodedata.attr[4])
            end
            if IsBlank(nodedata.attr[5]) then
                return string.format(
                        "_editor_class[%q]=Class(boss)\
_editor_class[%q].cards={}\
_editor_class[%q].name=%q\
_editor_class[%q].init=function(self,cards)\
	self.ex={}\
	boss.init(self,%s,%q,cards,New(%s),%q)\
	_editor_class[%q].initex(self)\
end\
_editor_class[%q].bgm = %q\
_editor_class[%q]._bg = %s\
_editor_class[%q].difficulty = %q\
_editor_class[%q].initex=function(self)\
local _temp=self\
self=self.ex\n"
                , className, className, className, nodedata.attr[2], className, nodedata.attr[3], nodedata.attr[2],
                        scbg, difficulty, className, className, nodedata.attr[11], className, _bg, className, difficulty, className)
            else
                local fn = wx.wxFileName(nodedata.attr[5]):GetFullName()
                return string.format(
                --"LoadImageGroupFromFile('anonymous:'..%q,%q,false,%s,%s,%s)\
                        "LoadTexture('anonymous:'..%q,%q)\
bossimg_number_n={%s}\
--bossimg_number_m={%s}\
bosstexture_n,bosstexture_m=GetTextureSize('anonymous:'..%q)\
bossimg_w,bossimg_h=bosstexture_n/%s,bosstexture_m/%s\
for i=1,%s do\
	LoadImageGroup('anonymous:'..%q..i,'anonymous:'..%q,0,  bossimg_h*(i-1),bossimg_w,bossimg_h,bossimg_number_n[i],1,%s)\
end\
_editor_class[%q]=Class(boss)\
_editor_class[%q].cards={}\
_editor_class[%q].name=%q\
_editor_class[%q].init=function(self,cards)\
	self.ex={}\
	boss.init(self,%s,%q,cards,New(%s),%q)\
	self.ani_intv=%s\
	for i=1,%s do self['img'..i]={} end\
	self.nn={%s}\
	self.mm={%s}\
	for i=2,%s do self['ani'..i]=self.nn[i]-self.mm[i-1] end\
	for i=1,%s do\
		for j=1,self.nn[i] do\
			self['img'..i][j]='anonymous:'..%q..i..j\
		end\
	end\
	_editor_class[%q].initex(self)\
end\
_editor_class[%q].bgm = %q\
_editor_class[%q]._bg = %s\
_editor_class[%q].difficulty = %q\
_editor_class[%q].initex=function(self)\
local _temp=self\
self=self.ex\n"
                , fn, fn, nodedata.attr[12], nodedata.attr[13], fn, nodedata.attr[6], nodedata.attr[7],
                        nodedata.attr[7], fn, fn, nodedata.attr[8],
                        className, className, className, nodedata.attr[2], className, nodedata.attr[3], nodedata.attr[2], scbg, difficulty,
                        nodedata.attr[9], nodedata.attr[7], nodedata.attr[12], nodedata.attr[13],
                        nodedata.attr[7], nodedata.attr[7], fn,
                        className, className, nodedata.attr[11], className, _bg, className, difficulty, className)
            end
        end,
        tofoot = function()
            difficulty = nil
            return 'self=_temp\nend\n'
        end,
        check = function(nodedata)
            if not IsBlank(nodedata.attr[5]) then
                local absfn = MakeFullPath(nodedata.attr[5])
                if not wx.wxFileName(absfn):FileExists() then
                    return string.format("Resource file %q does not exist", absfn)
                end
                local fn = wx.wxFileName(nodedata.attr[5]):GetFullName()
                if not CheckAnonymous(fn, absfn) then
                    return string.format("Repeated resource file name %q", fn)
                end
                local f, msg = io.open("editor\\tmp\\_pack_res.bat", "a")
                if msg then
                    return msg
                end
                f:write(string.format('..\\tools\\7z\\7z u -tzip -mcu=on "..\\game\\mod\\%s.zip" "%s"\n', outputName, absfn))
                f:close()
            end
            if nodedata.attr[4] ~= '' and (not watchDict.bgdefine[nodedata.attr[4]]) then
                return string.format('background type %q does not exist', nodedata.attr[4])
            end
            difficulty = string.match(nodedata.attr[1], '^.+:(.+)$')
        end,
        checkafter = function()
            difficulty = nil
        end,
    },
    bosspreparecards = {
        { 'Total SCs Left', 'any' },
        { 'Card 1', 'any' },
        { 'Card 2', 'any' },
        { 'Card 3', 'any' },
        { 'Card 4', 'any' },
        { 'Card 5', 'any' },
        disptype = 'prepare multriple cards',
        default = { ["type"] = 'bosspreparecards', attr = { '', '', '', '', '' } },
        needancestor = { 'task', 'bossscbefore', 'bossexdefine' },
        allowchild = {},
        totext = function(nodedata)
            local a = 0
            if not IsBlank(nodedata.attr[2]) then
                a = a + 1
            end
            if not IsBlank(nodedata.attr[3]) then
                a = a + 1
            end
            if not IsBlank(nodedata.attr[4]) then
                a = a + 1
            end
            if not IsBlank(nodedata.attr[5]) then
                a = a + 1
            end
            if not IsBlank(nodedata.attr[6]) then
                a = a + 1
            end

            return "preparing to cast " .. a .. " card(s)/non-card(s)"
        end,
        tohead = function(nodedata)
            local a = ""
            local b = false
            for i = 6, 2, -1 do
                if not IsBlank(nodedata.attr[i]) then
                    if b then
                        a = a .. ','
                    end
                    a = a .. '"' .. nodedata.attr[i] .. '"'
                    b = true
                end
            end
            if not IsBlank(nodedata.attr[1]) then
                return "self.ui.sc_left = " .. nodedata.attr[1] .. "\nboss.prepareSpellCards(self,{" .. a .. "})\n"
            end
            return "boss.prepareSpellCards(self,{" .. a .. "})\n"
        end,
    },
    bosscastcard = {
        { 'Card id', 'any' },
        { 'Wait for finish', 'bool', CheckExpr },
        disptype = 'do cast card',
        default = { ["type"] = 'bosscastcard', attr = { '', 'true' } },
        needancestor = { 'task', 'bossscbefore', 'bossexdefine' },
        allowchild = {},
        totext = function(nodedata)
            local a = 0
            local b = ''
            if IsBlank(nodedata.attr[1]) then
                a = 'next card'
            else
                a = nodedata.attr[1]
            end
            if nodedata.attr[2] == 'true' then
                b = 'and finish '
            end
            return "cast " .. b .. '"' .. a .. '"'
        end,
        tohead = function(nodedata)
            if IsBlank(nodedata.attr[1]) then
                return "boss.castSpell(self,nil," .. nodedata.attr[2] .. ")\n"
            else
                return "boss.castSpell(self," .. '"' .. nodedata.attr[1] .. '",' .. nodedata.attr[2] .. ")\n"
            end

        end,
    },
    bosscoopcard = {
        { 'Cooperate id', 'any' },
        { 'mode', 'any' },
        { 'wait after finish', 'any' },
        disptype = 'do cast card',
        default = { ["type"] = 'bosscoopcard', attr = { '1', '0', '30' } },
        needancestor = { 'task', 'bossscbefore', 'bossexdefine' },
        allowchild = {},
        totext = function(nodedata)
            return 'join coop card cast ' .. nodedata.attr[1] .. ' ( mode ' .. nodedata.attr[2] .. ' ) then wait ' .. nodedata.attr[3] .. ' frames'
        end,
        tohead = function(nodedata)
            return "ex.coopSpellCard(self," .. nodedata.attr[1] .. "," .. nodedata.attr[2] .. "," .. nodedata.attr[3] .. ")\n"
        end,
    },
    bossexplode = {
        { 'Is explode', 'bool', CheckExpr },
        { 'Is finish spell', 'bool', CheckExpr },
        disptype = 'finish boss ex',
        default = { ["type"] = 'bossexplode', attr = { 'false' } },
        needancestor = { 'task', 'bossscbefore', 'bossexdefine' },
        allowchild = {},
        totext = function(nodedata)
            local a = 0
            if nodedata.attr[2] == 'true' then
                return 'finish spell'
            end
            if nodedata.attr[1] == 'true' then
                a = 'explode'
            else
                a = 'run away'
            end
            return a
        end,
        tohead = function(nodedata)
            if nodedata.attr[2] == 'true' then
                return "boss.finishSpell(self," .. nodedata.attr[1] .. ")\n"
            end
            return "boss.explode(self," .. nodedata.attr[1] .. ")\n"
        end,
    },
    --boss bg
    bgdefine = {
        { 'Type name', 'any', CheckClassName },
        disptype = 'define boss\'s background',
        editfirst = true,
        allowparent = { 'root', 'folder' },
        watch = 'bgdefine',
        allowchild = { 'bglayer' },
        totext = function(nodedata)
            return string.format("define background type %q", nodedata.attr[1])
        end,
        tohead = function(nodedata)
            return string.format("_editor_class[%q]=Class(_spellcard_background)\n_editor_class[%q].init=function(self)\n    _spellcard_background.init(self)\n", nodedata.attr[1], nodedata.attr[1])
        end,
        tofoot = function()
            return 'end\n'
        end,
    },
    bglayer = {
        { 'Image', 'image', CheckNonBlank },
        { 'Is tile', 'bool', CheckExpr },
        { 'x', 'any', CheckExpr },
        { 'y', 'any', CheckExpr },
        { 'rot', 'any', CheckExpr },
        { 'vx', 'any', CheckExpr },
        { 'vy', 'any', CheckExpr },
        { 'omiga', 'any', CheckExpr },
        { 'Blend mode', 'blend', CheckExprOmit },
        { 'hscale', 'any', CheckExpr },
        { 'vscale', 'any', CheckExpr },
        --{'Extra init action','any',CheckCode},
        --{'Extra frame action','any',CheckCode},
        disptype = 'layer',
        editfirst = true,
        default = {
            ["type"] = 'bglayer',
            attr = { '', 'false', '0', '0', '0', '0', '0', '0', '', '1', '1' },
            expand = true,
            child = { { ["type"] = "bginit" }, { ['type'] = "bgframe" }, { ['type'] = "bgrender" } },
        },
        allowparent = { 'bgdefine' },
        allowchild = { 'bginit', 'bgframe', 'bgrender' },
        totext = function(nodedata)
            return string.format("layer %q", nodedata.attr[1])
        end,
        tohead = function(nodedata)
            local attr = nodedata.attr
            --local init_code, frame_code
            --if IsBlank(attr[12]) then  init_code='nil' else  init_code=string.format('function(self) %s end',attr[12]) end
            --if IsBlank(attr[13]) then frame_code='nil' else frame_code=string.format('function(self) %s end',attr[13]) end
            return string.format('_spellcard_background.AddLayer(self,%q,%s,%s,%s,%s,%s,%s,%s,%q,%s,%s,\n',
                    attr[1], attr[2], attr[3], attr[4], attr[5], attr[6], attr[7],
                    attr[8], attr[9], attr[10], attr[11]
            )
        end,
        tofoot = function()
            return ")\n"
        end,
        check = function()
            --			if not watchDict.imageonly[nodedata.attr[1]] then return string.format('image %q does not exist',nodedata.attr[1]) end
        end
    },
    bginit = {
        allowparent = { 'bglayer' },
        --allowchild={"task"},
        totext = function()
            return "on create"
        end,
        tohead = function()
            return "function(self)\nself.task={}\n"
        end,
        tofoot = function()
            return "end,\n"
        end,
    },
    bgframe = {
        allowparent = { 'bglayer' },
        --allowchild={"task"},
        totext = function()
            return "on frame"
        end,
        tohead = function()
            return "function(self)\ntask.Do(self)\n"
        end,
        tofoot = function()
            return "end,\n"
        end,
    },
    bgrender = {
        allowparent = { 'bglayer' },
        --allowchild={"task"},
        totext = function()
            return "on render"
        end,
        tohead = function()
            return "function(self)\ntask.Do(self)\n"
        end,
        tofoot = function()
            return "end\n"
        end,
    },
    --sound
    playsound = {
        { 'Sound name', 'sound', CheckNonBlank },
        { 'Volume', 'any', CheckExpr },
        { 'Pan', 'any', CheckExpr },
        { 'not use default vol', 'bool' },
        disptype = 'play sound',
        default = {
            ["type"] = "playsound",
            attr = { 'tan00', '0.1', '0', false }--{'tan00','0.1','self.x/256',false}
        },
        allowchild = {},
        forbidparent = { 'root', 'folder' },
        totext = function(nodedata)
            return string.format("play sound %q volume %s", nodedata.attr[1], nodedata.attr[2])
        end,
        tohead = function(nodedata)
            if IsBlank(nodedata.attr[4]) then
                nodedata.attr[4] = false
            end
            return string.format("PlaySound(%q,%s,%s,%s)\n", nodedata.attr[1], nodedata.attr[2], nodedata.attr[3], nodedata.attr[4])
        end,
        check = function(nodedata)
            if not (watchDict.sound[nodedata.attr[1]] or resList.snd[nodedata.attr[1]]) then
                return string.format('sound %q does not exist', nodedata.attr[1])
            end
        end,
    },
    playbgm = {
        { 'Music name', 'any', CheckNonBlank },
        { 'Time', 'any' },
        { 'SetStageTime', 'bool' },
        disptype = 'play background music',
        allowchild = {},
        forbidparent = { 'root', 'folder' },
        totext = function(nodedata)
            return string.format("play background music %q", nodedata.attr[1])
        end,
        tohead = function(nodedata)
            local rt1
            local rt2 = 'int(' .. nodedata.attr[2] .. '/60)'
            if not IsBlank(nodedata.attr[2]) then
                rt1 = string.format("LoadMusicRecord(%q);_play_music(%q,%s)\n", nodedata.attr[1], nodedata.attr[1], nodedata.attr[2])
            else
                rt1 = string.format("LoadMusicRecord(%q);_play_music(%q)\n", nodedata.attr[1], nodedata.attr[1])
                rt2 = '0'
            end
            if not IsBlank(nodedata.attr[3]) then
                rt1 = rt1 .. "if " .. nodedata.attr[3] .. " then ex.stageframe=" .. rt2 .. ' end\n'
            end
            return rt1
        end,
    },
    setpace = {
        { 'Start Time', 'any', CheckExpr },
        { 'Pace Time', 'any', CheckExpr },
        disptype = 'set pace',
        allowchild = {},
        forbidparent = { 'root', 'folder' },
        totext = function(nodedata)
            return string.format("set pace start %s seconds, tick %s seconds", nodedata.attr[1], nodedata.attr[2])
        end,
        tohead = function(nodedata)
            return 'ex.meterstart=' .. nodedata.attr[1] .. ' ex.meterclock=' .. nodedata.attr[2] .. '\n'
        end,
    },
    pausebgm = {
        disptype = 'pause background music',
        allowchild = {},
        forbidparent = { 'root', 'folder' },
        totext = function()
            return "pause background music"
        end,
        tohead = function()
            return "_pause_music()\n"
        end,
    },
    resumebgm = {
        disptype = 'resume background music',
        allowchild = {},
        forbidparent = { 'root', 'folder' },
        totext = function()
            return "resume background music"
        end,
        tohead = function()
            return "_resume_music()\n"
        end,
    },
    stopbgm = {
        disptype = 'stop background music',
        allowchild = {},
        forbidparent = { 'root', 'folder' },
        totext = function()
            return "stop background music"
        end,
        tohead = function()
            return "_stop_music()\n"
        end,
    },
    --res
    loadsound = {
        { 'File path', 'resfile', CheckNonBlank },
        { 'Resource name', 'any', CheckNonBlank },
        disptype = 'load sound',
        editfirst = true,
        watch = 'sound',
        allowchild = {},
        allowparent = { 'root', 'folder' },
        totext = function(nodedata)
            return string.format("load sound %q from %q", nodedata.attr[2], nodedata.attr[1])
        end,
        tohead = function(nodedata)
            return string.format("LoadSound(%q,%q)\n", nodedata.attr[2], wx.wxFileName(nodedata.attr[1]):GetFullName())
        end,
        check = function(nodedata)
            if resList.snd[nodedata.attr[2]] then
                return string.format("Repeated resource name %q (name already exists in THlib)", nodedata.attr[2])
            end
            if checkSoundName[nodedata.attr[2]] == nil then
                checkSoundName[nodedata.attr[2]] = true
            else
                return string.format("Repeated resource name %q", nodedata.attr[2])
            end
            local absfn = MakeFullPath(nodedata.attr[1])
            if not wx.wxFileName(absfn):FileExists() then
                return string.format("Resource file %q does not exist", absfn)
            end
            local fn = wx.wxFileName(nodedata.attr[1]):GetFullName()
            if not CheckResFileInPack(fn) then
                return string.format("Repeated resource file name %q", fn)
            end
            local f, msg = io.open("editor\\tmp\\_pack_res.bat", "a")
            if msg then
                return msg
            end
            f:write(string.format('..\\tools\\7z\\7z u -tzip -mcu=on "..\\game\\mod\\%s.zip" "%s"\n', outputName, absfn))
            f:close()
        end
    },
    loadbgm = {
        { 'File path', 'resfile', CheckNonBlank },
        { 'Resource name', 'any', CheckNonBlank },
        { 'Loop end (seconds)', 'any', CheckExpr },
        { 'Loop length (seconds)', 'any', CheckExpr },
        disptype = 'load background music',
        editfirst = true,
        watch = 'bgm',
        allowchild = {},
        allowparent = { 'root', 'folder', 'codeblock' },
        totext = function(nodedata)
            return string.format("load background music %q from %q", nodedata.attr[2], nodedata.attr[1])
        end,
        tohead = function(nodedata)
            return string.format("MusicRecord(%q,%q,%s,%s)\n", nodedata.attr[2], wx.wxFileName(nodedata.attr[1]):GetFullName(), nodedata.attr[3], nodedata.attr[4])
        end,
        check = function(nodedata)
            local absfn = MakeFullPath(nodedata.attr[1])
            if not wx.wxFileName(absfn):FileExists() then
                return string.format("Resource file %q does not exist", absfn)
            end
            if checkBgmName[nodedata.attr[2]] == nil then
                checkBgmName[nodedata.attr[2]] = nodedata.attr[1]
                local fn = wx.wxFileName(nodedata.attr[1]):GetFullName()
                if not CheckResFileInPack(fn) then
                    return string.format("Repeated resource file name %q", fn)
                end
                local f, msg = io.open("editor\\tmp\\_pack_res.bat", "a")
                if msg then
                    return msg
                end
                f:write(string.format('..\\tools\\7z\\7z u -tzip -mcu=on "..\\game\\mod\\%s.zip" "%s"\n', outputName, absfn))
                f:close()
            else
                if checkBgmName[nodedata.attr[2]] ~= nodedata.attr[1] then
                    return string.format("Repeated resource name %q", nodedata.attr[2])
                end
            end
        end
    },
    loadimage = {
        { 'File path', 'resfile', CheckNonBlank },
        { 'Resource name', 'any', CheckNonBlank },
        { 'Mipmap', 'bool', CheckExpr },
        { 'Collision size', 'any', CheckExpr },
        { 'Rectangle collision', 'bool', CheckExpr },
        { 'Cut edge', 'any', CheckExpr, '0' },
        disptype = 'load image',
        editfirst = true,
        default = { ["type"] = 'loadimage', attr = { '', '', 'true', '0,0', 'false', '0' } },
        watch = 'image',
        allowchild = {},
        allowparent = { 'root', 'folder' },
        totext = function(nodedata)
            return string.format("load image %q from %q", nodedata.attr[2], nodedata.attr[1])
        end,
        tohead = function(nodedata)
            return string.format("_LoadImageFromFile('image:'..%q,%q,%s,%s,%s,%s)\n", nodedata.attr[2], wx.wxFileName(nodedata.attr[1]):GetFullName(), nodedata.attr[3], nodedata.attr[4], nodedata.attr[5], nodedata.attr[6])
        end,
        check = function(nodedata)
            if checkImageName[nodedata.attr[2]] == nil then
                checkImageName[nodedata.attr[2]] = true
            else
                return string.format("Repeated resource name %q", nodedata.attr[2])
            end
            local absfn = MakeFullPath(nodedata.attr[1])
            if not wx.wxFileName(absfn):FileExists() then
                return string.format("Resource file %q does not exist", absfn)
            end
            local fn = wx.wxFileName(nodedata.attr[1]):GetFullName()
            if not CheckResFileInPack(fn) then
                return string.format("Repeated resource file name %q", fn)
            end
            local msg = CheckAddRes(absfn, fn)
            --local f,msg=io.open("editor\\tmp\\_pack_res.bat","a")
            if msg then
                return msg
            end
            --f:write(string.format('..\\tools\\7z\\7z u -tzip -mcu=on "..\\game\\mod\\%s.zip" "%s"\n',outputName,absfn))
            --f:close()
        end
    },
    loadtexture = {
        { 'File path', 'resfile', CheckNonBlank },
        { 'Resource name', 'any', CheckNonBlank },
        { 'Mipmap', 'bool', CheckExpr },
        disptype = 'load texture',
        editfirst = true,
        default = { ["type"] = 'loadtexture', attr = { '', '', 'true' } },
        watch = 'image',
        allowchild = {},
        allowparent = { 'root', 'folder' },
        totext = function(nodedata)
            return string.format("load texture %q from %q", nodedata.attr[2], nodedata.attr[1])
        end,
        tohead = function(nodedata)
            return string.format("LoadTexture('texture:'..%q,%q,%s)\n", nodedata.attr[2], wx.wxFileName(nodedata.attr[1]):GetFullName(), nodedata.attr[3])
        end,
        check = function(nodedata)
            if checkImageName[nodedata.attr[2]] == nil then
                checkImageName[nodedata.attr[2]] = true
            else
                return string.format("Repeated resource name %q", nodedata.attr[2])
            end
            local absfn = MakeFullPath(nodedata.attr[1])
            if not wx.wxFileName(absfn):FileExists() then
                return string.format("Resource file %q does not exist", absfn)
            end
            local fn = wx.wxFileName(nodedata.attr[1]):GetFullName()
            if not CheckResFileInPack(fn) then
                return string.format("Repeated resource file name %q", fn)
            end
            local msg = CheckAddRes(absfn, fn)
            --local f,msg=io.open("editor\\tmp\\_pack_res.bat","a")
            if msg then
                return msg
            end
            --f:write(string.format('..\\tools\\7z\\7z u -tzip -mcu=on "..\\game\\mod\\%s.zip" "%s"\n',outputName,absfn))
            --f:close()
        end
    },
    loadmodel = {
        { 'File path', 'resfile', CheckNonBlank },
        { 'Resource name', 'any', CheckNonBlank },
        disptype = 'load model',
        editfirst = true,
        default = { ["type"] = 'loadmodel', attr = { '', '' } },
        watch = 'image',
        allowchild = {},
        allowparent = { 'root', 'folder' },
        totext = function(nodedata)
            return string.format("load model %q from %q", nodedata.attr[2], nodedata.attr[1])
        end,
        tohead = function(nodedata)
            return string.format("LoadModel('model:'..%q,%q)\n", nodedata.attr[2], wx.wxFileName(nodedata.attr[1]):GetFullName(), nodedata.attr[3])
        end,
        check = function(nodedata)
            if checkImageName[nodedata.attr[2]] == nil then
                checkImageName[nodedata.attr[2]] = true
            else
                return string.format("Repeated resource name %q", nodedata.attr[2])
            end
            local absfn = MakeFullPath(nodedata.attr[1])
            if not wx.wxFileName(absfn):FileExists() then
                return string.format("Resource file %q does not exist", absfn)
            end
            local fn = wx.wxFileName(nodedata.attr[1]):GetFullName()
            if not CheckResFileInPack(fn) then
                return string.format("Repeated resource file name %q", fn)
            end
            local msg = CheckAddRes(absfn, fn)
            --local f,msg=io.open("editor\\tmp\\_pack_res.bat","a")
            if msg then
                return msg
            end
            --f:write(string.format('..\\tools\\7z\\7z u -tzip -mcu=on "..\\game\\mod\\%s.zip" "%s"\n',outputName,absfn))
            --f:close()
        end
    },
    loadimagegroup = {
        { 'File path', 'resfile', CheckNonBlank },
        { 'Resource name', 'any', CheckNonBlank },
        { 'Mipmap', 'bool', CheckExpr },
        { 'cols and rows', 'any', CheckExpr },
        { 'Collision size', 'any', CheckExpr },
        { 'Rectangle collision', 'bool', CheckExpr },
        disptype = 'load image group',
        editfirst = true,
        default = { ["type"] = 'loadimagegroup', attr = { '', '', 'true', '4,1', '0,0', '0' } },
        watch = 'image',
        allowchild = {},
        allowparent = { 'root', 'folder' },
        totext = function(nodedata)
            return string.format("load image group %q from %q", nodedata.attr[2], nodedata.attr[1])
        end,
        tohead = function(nodedata)
            return string.format("_LoadImageGroupFromFile('image:'..%q,%q,%s,%s,%s,%s)\n", nodedata.attr[2], wx.wxFileName(nodedata.attr[1]):GetFullName(), nodedata.attr[3], nodedata.attr[4], nodedata.attr[5], nodedata.attr[6])
        end,
        check = function(nodedata)
            if checkImageName[nodedata.attr[2]] == nil then
                checkImageName[nodedata.attr[2]] = true
            else
                return string.format("Repeated resource name %q", nodedata.attr[2])
            end
            local absfn = MakeFullPath(nodedata.attr[1])
            if not wx.wxFileName(absfn):FileExists() then
                return string.format("Resource file %q does not exist", absfn)
            end
            local fn = wx.wxFileName(nodedata.attr[1]):GetFullName()
            if not CheckResFileInPack(fn) then
                return string.format("Repeated resource file name %q", fn)
            end
            local msg = CheckAddRes(absfn, fn)
            --local f,msg=io.open("editor\\tmp\\_pack_res.bat","a")
            if msg then
                return msg
            end
            --f:write(string.format('..\\tools\\7z\\7z u -tzip -mcu=on "..\\game\\mod\\%s.zip" "%s"\n',outputName,absfn))
            --f:close()
        end
    },
    loadani = {
        { 'File path', 'resfile', CheckNonBlank },
        { 'Resource name', 'any', CheckNonBlank },
        { 'Mipmap', 'bool', CheckExpr },
        { 'nCol', 'any', CheckExpr },
        { 'nRow', 'any', CheckExpr },
        { 'Interval', 'any', CheckExpr },
        { 'Collision size', 'any', CheckExpr },
        { 'Rectangle collision', 'bool', CheckExpr },
        disptype = 'load animation',
        editfirst = true,
        default = { ["type"] = 'loadani', attr = { '', '', 'true', '1', '1', '4', '0,0', 'false' } },
        watch = 'image',
        allowchild = {},
        allowparent = { 'root', 'folder' },
        totext = function(nodedata)
            return string.format("load animation %q from %q", nodedata.attr[2], nodedata.attr[1])
        end,
        tohead = function(nodedata)
            return string.format("LoadAniFromFile('ani:'..%q,%q,%s,%s,%s,%s,%s,%s)\n", nodedata.attr[2], wx.wxFileName(nodedata.attr[1]):GetFullName(), nodedata.attr[3], nodedata.attr[4], nodedata.attr[5], nodedata.attr[6], nodedata.attr[7], nodedata.attr[8])
        end,
        check = function(nodedata)
            if checkAniName[nodedata.attr[2]] == nil then
                checkAniName[nodedata.attr[2]] = true
            else
                return string.format("Repeated resource name %q", nodedata.attr[2])
            end
            local absfn = MakeFullPath(nodedata.attr[1])
            if not wx.wxFileName(absfn):FileExists() then
                return string.format("Resource file %q does not exist", absfn)
            end
            local fn = wx.wxFileName(nodedata.attr[1]):GetFullName()
            if not CheckResFileInPack(fn) then
                return string.format("Repeated resource file name %q", fn)
            end
            local f, msg = io.open("editor\\tmp\\_pack_res.bat", "a")
            if msg then
                return msg
            end
            f:write(string.format('..\\tools\\7z\\7z u -tzip -mcu=on "..\\game\\mod\\%s.zip" "%s"\n', outputName, absfn))
            f:close()
        end
    },
    loadparticle = {
        { 'File path', 'resfile', CheckNonBlank },
        { 'Resource name', 'any', CheckNonBlank },
        { 'Image', 'image', CheckParImage },
        { 'Collision size', 'any', CheckExpr },
        { 'Rectangle collision', 'bool', CheckExpr },
        disptype = 'load particle effect',
        editfirst = true,
        default = { ["type"] = 'loadparticle', attr = { '', '', '', '0,0', 'false' } },
        watch = 'image',
        allowchild = {},
        allowparent = { 'root', 'folder' },
        totext = function(nodedata)
            return string.format("load particle system %q from %q", nodedata.attr[2], nodedata.attr[1])
        end,
        tohead = function(nodedata)
            return string.format("LoadPS('particle:'..%q,%q,%q,%s,%s)\n", nodedata.attr[2], wx.wxFileName(nodedata.attr[1]):GetFullName(), nodedata.attr[3], nodedata.attr[4], nodedata.attr[5])
        end,
        check = function(nodedata)
            if checkParName[nodedata.attr[2]] == nil then
                checkParName[nodedata.attr[2]] = true
            else
                return string.format("Repeated resource name %q", nodedata.attr[2])
            end
            local absfn = MakeFullPath(nodedata.attr[1])
            if not wx.wxFileName(absfn):FileExists() then
                return string.format("Resource file %q does not exist", absfn)
            end
            local fn = wx.wxFileName(nodedata.attr[1]):GetFullName()
            if not CheckResFileInPack(fn) then
                return string.format("Repeated resource file name %q", fn)
            end
            local f, msg = io.open("editor\\tmp\\_pack_res.bat", "a")
            if msg then
                return msg
            end
            f:write(string.format('..\\tools\\7z\\7z u -tzip -mcu=on "..\\game\\mod\\%s.zip" "%s"\n', outputName, absfn))
            f:close()
            if not (watchDict.imageonly[nodedata.attr[3]] or parimg[nodedata.attr[3]]) then
                return string.format('image %q does not exist', nodedata.attr[3])
            end
        end
    },
    loadFX = {
        { 'File path', 'resfile', CheckNonBlank },
        { 'Resource name', 'any', CheckNonBlank },
        disptype = 'loadFX',
        editfirst = true,
        default = { ["type"] = 'loadFX', attr = { '', '', } },
        watch = 'image',
        allowchild = {},
        allowparent = { 'root', 'folder' },
        totext = function(nodedata)
            return string.format("load FX %q from %q", nodedata.attr[2], nodedata.attr[1])
        end,
        tohead = function(nodedata)
            return string.format("LoadFX(%q,%q)\n", nodedata.attr[2], wx.wxFileName(nodedata.attr[1]):GetFullName())
        end,
        check = function(nodedata)
            if checkImageName[nodedata.attr[2]] == nil then
                checkImageName[nodedata.attr[2]] = true
            else
                return string.format("Repeated resource name %q", nodedata.attr[2])
            end
            local absfn = MakeFullPath(nodedata.attr[1])
            if not wx.wxFileName(absfn):FileExists() then
                return string.format("Resource file %q does not exist", absfn)
            end
            local fn = wx.wxFileName(nodedata.attr[1]):GetFullName()
            if not CheckResFileInPack(fn) then
                return string.format("Repeated resource file name %q", fn)
            end
            local f, msg = io.open("editor\\tmp\\_pack_res.bat", "a")
            if msg then
                return msg
            end
            f:write(string.format('..\\tools\\7z\\7z u -tzip -mcu=on "..\\game\\mod\\%s.zip" "%s"\n', outputName, absfn))
            f:close()
        end
    },
    FileAddIntoPack = {
        { 'File Path', 'resfile', CheckNonBlank },
        { 'Zip Path', 'any' },
        disptype = 'add something into the pack',
        allowparent = { 'root', 'folder' },
        allowchild = {},
        editfirst = true,
        totext = function(nodedata)
            return string.format("Add %q into the pack", nodedata.attr[1])
        end,
        check = function(nodedata)
            if not IsBlank(nodedata.attr[1]) then
                local absfn = MakeFullPath(nodedata.attr[1])
                if not wx.wxFileName(absfn):FileExists() then
                    return string.format("Resource file %q does not exist", absfn)
                end
                local fn = wx.wxFileName(nodedata.attr[1]):GetFullName()
                if not CheckAnonymous(fn, absfn) then
                    return string.format("Repeated resource file name %q", fn)
                end
                local f, msg = io.open("editor\\tmp\\_pack_res.bat", "a")
                if msg then
                    return msg
                end
                if not IsBlank(nodedata.attr[2]) then
                    local s = nodedata.attr[2]
                    if string.sub(nodedata.attr[2], -1, -1) == "\\" then
                        s = string.sub(nodedata.attr[2], 1, -2)
                    end
                    f:write(string.format('\
md ..\\game\\mod\\%s\\ \
copy /y %q "..\\game\\mod\\%s\\"\
cd ..\\game\\mod\\ \
..\\..\\tools\\7z\\7z a -tzip -mcu=on "%s.zip" "%s\\"\
rd /s /q %s\
cd ..\\..\\editor\\\n', s, absfn, s, outputName, s, s))
                else
                    f:write(string.format('..\\tools\\7z\\7z u -tzip -mcu=on "..\\game\\mod\\%s.zip" "%s"\n', outputName, absfn))
                end
                f:close()
            end
        end,
    },
    --unit
    ['properties'] = {
        { 'Unit', 'target', CheckExpr },
        { 'Property', 'properties' },
        { 'Value', 'any' },
        { 'Property', 'properties' },
        { 'Value', 'any' },
        { 'Property', 'properties' },
        { 'Value', 'any' },
        { 'Property', 'properties' },
        { 'Value', 'any' },
        default = { ["type"] = 'properties', attr = { 'self', '', '', '', '', '', '', '', '', '', '', '', '' } },
        forbidparent = { 'root', 'folder' },
        check = function(nodedata)
            local attr = nodedata.attr
            for i = 2, 8, 2 do
                if not IsBlank(attr[i]) then
                    if IsBlank(attr[i + 1]) then
                        return string.format("Properties '%s' is not set:", attr[i])
                    end
                end
            end
        end,
        totext = function(nodedata)
            local ret = "set " .. nodedata.attr[1] .. "'s "
            local attr = nodedata.attr
            for i = 2, 8, 2 do
                if not IsBlank(attr[i]) and not IsBlank(attr[i + 1]) then
                    ret = ret .. " (" .. attr[i] .. "=" .. attr[i + 1] .. ")"
                end
            end
            return ret
        end,
        tohead = function(nodedata)
            local ret = ""
            local attr = nodedata.attr
            for i = 2, 8, 2 do
                if not IsBlank(attr[i]) then
                    ret = ret .. string.format("%s[%q]=%s ", attr[1], attr[i], attr[i + 1])
                end
            end
            return ret;
        end,
    },
    setv = {
        { 'Unit', 'target', CheckExpr },
        { 'Velocity', 'any', CheckExpr },
        { 'Angle', 'any', CheckExpr },
        { 'Aim to player', 'bool', CheckExpr },
        { 'Set rotation', 'bool', CheckExpr },
        disptype = 'set velocity',
        forbidparent = { 'folder', 'root' },
        allowchild = {},
        default = { ['type'] = 'setv', attr = { 'self', '3', '0', 'false', 'true' } },
        totext = function(nodedata)
            local aim
            if nodedata.attr[4] == 'true' then
                aim = ' aim to player'
            else
                aim = ''
            end
            return string.format("set %s's velocity=%s angle=%s%s", nodedata.attr[1], nodedata.attr[2], nodedata.attr[3], aim)
        end,
        tohead = function(nodedata)
            return string.format("SetV2(%s,%s,%s,%s,%s)\n", nodedata.attr[1], nodedata.attr[2], nodedata.attr[3], nodedata.attr[5], nodedata.attr[4])
        end,
    },
    setaccel = {
        { 'Unit', 'target', CheckExpr },
        { 'Acceleration', 'any', CheckExpr },
        { 'Angle', 'any', CheckExpr },
        { 'Aim to player', 'bool', CheckExpr },
        disptype = 'set acceleration',
        forbidparent = { 'root', 'folder' },
        allowchild = {},
        default = { ['type'] = 'setaccel', ['attr'] = { 'self', '0.05', '0', 'false' } },
        totext = function(nodedata)
            local ret
            if nodedata.attr[3] == 'original' then
                ret = "set acceleration of " .. nodedata.attr[2] .. " , at the velocity direction"
            else
                ret = "set acceleration of " .. nodedata.attr[2] .. " , angle of " .. nodedata.attr[3]
            end
            if nodedata.attr[4] == "true" then
                ret = ret .. ", aim to player"
            end
            return ret
        end,
        tohead = function(nodedata)
            local rot = nodedata.attr[3]
            if rot == "original" then
                rot = "'original'"
            end
            return string.format("_set_a(%s,%s,%s,%s)\n", nodedata.attr[1], nodedata.attr[2], rot, nodedata.attr[4])
        end
    },
    setgravity = {
        { 'Unit', 'target', CheckExpr },
        { 'Gravity', 'any', CheckExpr },
        disptype = 'set gravity',
        forbidparent = { 'root', 'folder' },
        allowchild = {},
        default = { ['type'] = 'setgravity', ['attr'] = { 'self', '0.05' } },
        totext = function(nodedata)
            return "set gravity of " .. nodedata.attr[2]
        end,
        tohead = function(nodedata)
            return string.format("_set_g(%s,%s)\n", nodedata.attr[1], nodedata.attr[2])
        end
    },
    setfv = {
        { 'Unit', 'target', CheckExpr },
        { 'Max Velocity', 'any', CheckExpr },
        { 'Max X-Velocity', 'any', CheckExpr },
        { 'Max Y-Velocity', 'any', CheckExpr },
        disptype = 'set velocity forbidance',
        forbidparent = { 'root', 'folder' },
        allowchild = {},
        default = { ['type'] = 'setfv', ['attr'] = { 'self', 'original', 'original', 'original' } },
        totext = function(nodedata)
            local ret = "set "
            if nodedata.attr[2] ~= "original" then
                if ret ~= "set " then
                    ret = ret .. ","
                end
                ret = ret .. " max velocity of " .. nodedata.attr[2]
            end
            if nodedata.attr[3] ~= "original" then
                if ret ~= "set " then
                    ret = ret .. ","
                end
                ret = ret .. " max X-velocity of " .. nodedata.attr[3]
            end
            if nodedata.attr[4] ~= "original" then
                if ret ~= "set " then
                    ret = ret .. ","
                end
                ret = ret .. " max Y-velocity of " .. nodedata.attr[4]
            end
            if ret == "set " then
                ret = ret .. "nothing"
            end
            return ret
        end,
        tohead = function(nodedata)
            local v, vx, vy = unpack(nodedata.attr, 2, 4)
            if v == "original" then
                v = "'original'"
            end
            if vx == "original" then
                vx = "'original'"
            end
            if vy == "original" then
                vy = "'original'"
            end
            return string.format("_forbid_v(%s,%s,%s,%s)\n", nodedata.attr[1], v, vx, vy)
        end
    },
    setcolor = {
        { 'Object', 'target', CheckExpr },
        { 'Blend mode', 'blend', CheckExprOmit },
        { 'Alpha', 'any', CheckExpr },
        { 'Red', 'any', CheckExpr },
        { 'Green', 'any', CheckExpr },
        { 'Blue', 'any', CheckExpr },
        disptype = 'change object\'s color and blend mode',
        forbidparent = { 'folder', 'root' },
        allowchild = {},
        default = { ['type'] = 'setcolor', attr = { 'self', '', '255', '255', '255', '255' } },
        totext = function(nodedata)
            return string.format("set %s's color to (%s,%s,%s,%s) and blend mode to %q", nodedata.attr[1], nodedata.attr[3], nodedata.attr[4], nodedata.attr[5], nodedata.attr[6], nodedata.attr[2])
        end,
        tohead = function(nodedata)
            return string.format("_object.set_color(%s,%q,%s,%s,%s,%s)\n", nodedata.attr[1], nodedata.attr[2], nodedata.attr[3], nodedata.attr[4], nodedata.attr[5], nodedata.attr[6])
        end,
    },
    objectsetimg = {
        { 'Object', 'target', CheckExpr },
        { 'Image', 'image', CheckNonBlank },
        { 'Index', 'any' },
        disptype = 'change object\'s image',
        forbidparent = { 'folder', 'root' },
        allowchild = {},
        default = { ['type'] = 'objectsetimg', attr = { 'self', '', '' } },
        totext = function(nodedata)
            local s = string.format("set %s's image to %q", nodedata.attr[1], nodedata.attr[2])
            if IsBlank(nodedata.attr[3]) then
                return s
            else
                return s .. '..' .. nodedata.attr[3]
            end
        end,
        tohead = function(nodedata)
            local s = string.format("%s.img=%q", nodedata.attr[1], nodedata.attr[2])
            if IsBlank(nodedata.attr[3]) then
                return s .. '\n'
            else
                return s .. '..' .. nodedata.attr[3] .. '\n'
            end
        end,
    },
    unitforeach = {
        { 'Group', 'group', CheckExpr },
        disptype = 'for each unit in group',
        forbidparent = { 'folder', 'root' },
        forbidancestor = { 'unitforeach' },
        totext = function(nodedata)
            return string.format("for each unit in group %s", nodedata.attr[1])
        end,
        tohead = function(nodedata)
            return string.format("for _,unit in ObjList(%s) do\n", nodedata.attr[1])
        end,
        tofoot = function()
            return "end\n"
        end,
    },
    unitkill = {
        { 'Unit', 'target', CheckExpr },
        { 'Trigger event', 'bool', CheckExpr },
        disptype = 'kill unit',
        forbidparent = { 'folder', 'root' },
        allowchild = {},
        default = { ['type'] = 'unitkill', attr = { 'self', 'true' } },
        totext = function(nodedata)
            return string.format("kill %s", nodedata.attr[1])
        end,
        tohead = function(nodedata)
            return string.format("_kill(%s,%s)\n", nodedata.attr[1], nodedata.attr[2])
        end,
    },
    unitdel = {
        { 'Unit', 'target', CheckExpr },
        { 'Trigger event', 'bool', CheckExpr },
        disptype = 'delete unit',
        forbidparent = { 'folder', 'root' },
        allowchild = {},
        default = { ['type'] = 'unitdel', attr = { 'self', 'true' } },
        totext = function(nodedata)
            return string.format("delete %s", nodedata.attr[1])
        end,
        tohead = function(nodedata)
            return string.format("_del(%s,%s)\n", nodedata.attr[1], nodedata.attr[2])
        end,
    },
    unitpreserve = {
        { 'Unit', 'target', CheckExpr },
        disptype = 'preserve unit',
        forbidparent = { 'folder', 'root' },
        allowchild = {},
        default = { ['type'] = 'unitpreserve', attr = { 'self' } },
        totext = function(nodedata)
            return string.format("preserve %s", nodedata.attr[1])
        end,
        tohead = function(nodedata)
            return string.format("PreserveObject(%s)\n", nodedata.attr[1])
        end,
    },
    connect = {
        { 'Master', 'target', CheckExpr },
        { 'Servant', 'target', CheckExpr },
        { 'Damage transfer', 'any', CheckExpr },
        { 'Connect death', 'bool', CheckExpr },
        default = { ['type'] = 'connect', attr = { 'self', 'last', '0', 'true' } },
        forbidparent = { 'root', 'folder' },
        allowchild = {},
        totext = function(nodedata)
            return string.format('set %s as servant of %s', nodedata.attr[2], nodedata.attr[1])
        end,
        tohead = function(nodedata)
            return string.format('_connect(%s,%s,%s,%s)\n', nodedata.attr[1], nodedata.attr[2], nodedata.attr[3], nodedata.attr[4])
        end,
    },
    setrelpos = {
        { 'Position', 'any', CheckPos },
        { 'Rotation', 'any', CheckExpr, 'self.rot' },
        { 'Follow master\'s rotation', 'bool', CheckExpr, 'false' },
        disptype = 'set relative position',
        default = { ['type'] = 'setrelpos', attr = { '0,0', 'self.rot', 'false' } },
        needancestor = { 'enemydefine', 'objectdefine', 'laserdefine', 'laserbentdefine', 'bulletdefine', 'taskdefine' },
        forbidparent = { 'enemyinit', 'objectinit', 'laserinit', 'laserbentinit', 'bulletinit' },
        allowchild = {},
        totext = function(nodedata)
            local ret = string.format('set position to (%s) relatively to master, set rot to %s', nodedata.attr[1], nodedata.attr[2])
            if nodedata.attr[3] == 'true' then
                ret = ret .. ', follow master\'s rot'
            end
            return ret
        end,
        tohead = function(nodedata)
            return string.format('_set_rel_pos(self,%s,%s,%s)\n', nodedata.attr[1], nodedata.attr[2], nodedata.attr[3])
        end,
    },
    callbackfunc = {
        { 'Event type', 'event', CheckNonBlank },
        disptype = 'unit event trigger',
        default = { expand = true, ['type'] = 'callbackfunc', attr = { 'frame' }, child = { { ['type'] = 'defaultaction', attr = {} } } },
        allowparent = { 'enemydefine', 'bossdefine', 'objectdefine', 'laserdefine', 'laserbentdefine', 'bulletdefine', 'rebounderdefine' },
        totext = function(nodedata)
            return "on " .. nodedata.attr[1]
        end,
        tohead = function(nodedata)
            eventType = nodedata.attr[1]
            if nodedata.attr[1] ~= 'colli' then
                return string.format("_editor_class[%q].%s=function(self)\n", className, nodedata.attr[1])
            else
                return string.format("_editor_class[%q].colli=function(self,other)\n", className)
            end
        end,
        tofoot = function()
            return "end\n"
        end,
        check = function(nodedata)
            if not event_type_dict[nodedata.attr[1]] then
                return string.format("unknown event type %q", nodedata.attr[1])
            end
        end,
    },
    defaultaction = {
        disptype = 'do default action',
        allowchild = {},
        allowparent = { 'callbackfunc' },
        totext = function()
            return "do default action"
        end,
        tohead = function()
            if eventType == 'colli' then
                return "self.class.base.colli(self,other)\n"
            else
                return string.format("self.class.base.%s(self)\n", eventType)
            end
        end
    },
    --effect
    smear = {
        { "Master", "target", CheckExpr },
        { "Interval (floating number)", "any", CheckExpr },
        default = { ["type"] = "smear", attr = { "self", "1" } },
        forbidparent = { "root", "folder" },
        allowchild = {},
        totext = function(nodedata)
            return string.format("make a smear of %s, interval of %s", unpack(nodedata.attr))
        end,
        tohead = function(nodedata)
            return string.format("last=New(smear, %s)\n", table.concat(nodedata.attr, ", "))
        end
    },
    shakescreen = {
        { 'time', 'any', CheckExpr },
        { 'amplitude', 'any', CheckExpr },
        disptype = 'shake screen',
        forbidparent = { 'root', 'folder' },
        allowchild = {},
        default = { ["type"] = 'shakescreen', attr = { '240', '3' } },
        totext = function(nodedata)
            return "Shake screen " .. nodedata.attr[1] .. " frames, amplitude of " .. nodedata.attr[2]
        end,
        tohead = function(nodedata)
            return "misc.ShakeScreen(" .. nodedata.attr[1] .. ", " .. nodedata.attr[2] .. ")\n"
        end
    },
    dropitem = {
        { 'Item', 'item' },
        { 'Number', 'any', CheckExpr },
        { 'Position', 'any', CheckPos },
        disptype = 'drop item',
        forbidparent = { 'root', 'folder' },
        allowchild = {},
        default = { ["type"] = 'dropitem', attr = { 'item_extend', '1', 'self.x,self.y' } },
        totext = function(nodedata)
            if nodedata.attr[2] == '0' then
                return "drop nothing"
            end
            local ret = "drop "
            if nodedata.attr[2] ~= '1' then
                ret = ret .. nodedata.attr[2] .. " "
            end
            return ret .. nodedata.attr[1] .. " in (" .. nodedata.attr[3] .. ")"
        end,
        tohead = function(nodedata)
            return string.format("_drop_item(%s)\n", table.concat(nodedata.attr, ","))
        end
    },
    pactrometer = {
        { 'Position', 'any', CheckPos },
		{ 'Radius', 'any' },
		{ 'R', 'any' },
		{ 'G', 'any' },
		{ 'B', 'any' },
		{ 'Time(in frames)', 'any' },
		{ 'Mode', 'any' },
		{ 'Not Play Sound', 'bool'  },
		{ 'master', 'any'  },
        disptype = 'boss pactrometer',
        default = { ["type"] = 'pactrometer', attr = { 'self.x,self.y','256','255','0','0','60','2','false' } },
        forbidparent = { 'root', 'folder' },
        allowchild = {},
        totext = function(nodedata)
            local ra = nodedata.attr[2]
            if IsBlank(ra) then ra = "default" end
            local r = nodedata.attr[3]
            if IsBlank(r) then r = "default" end
            local g = nodedata.attr[4]
            if IsBlank(g) then g = "default" end
            local b = nodedata.attr[5]
            if IsBlank(b) then b = "default" end
            local t = nodedata.attr[6]
            if IsBlank(t) then t = "default" end
            local mode = nodedata.attr[7]
            if IsBlank(mode) then mode = "default" end
            local ns = nodedata.attr[8]
            if IsBlank(ns) then ns = "default" end
            local master = nodedata.attr[9]
            if IsBlank(master) then
				return string.format('pactrometer in (%s),radius=%s,R=%s,G=%s,B=%s,in %s frames,mode=%s,is play sound=%s\n',nodedata.attr[1],ra,r,g,b,t,mode,ns)
			else
				return string.format('pactrometer in (%s),radius=%s,R=%s,G=%s,B=%s,in %s frames,mode=%s,is play sound=%s,follow %s\n',nodedata.attr[1],ra,r,g,b,t,mode,ns,master)
			end
        end,
        tohead = function(nodedata)
            local ra = nodedata.attr[2]
            if IsBlank(ra) then ra = "nil" end
            local r = nodedata.attr[3]
            if IsBlank(r) then r = "nil" end
            local g = nodedata.attr[4]
            if IsBlank(g) then g = "nil" end
            local b = nodedata.attr[5]
            if IsBlank(b) then b = "nil" end
            local t = nodedata.attr[6]
            if IsBlank(t) then t = "nil" end
            local mode = nodedata.attr[7]
            if IsBlank(mode) then mode = "nil" end
            local ns = nodedata.attr[8]
            if IsBlank(ns) then ns = "nil" end
            local master = nodedata.attr[9]
            if IsBlank(master) then master = "nil" end
            return string.format('New(boss_cast_ef,%s,%s,%s,%s,%s,%s,%s,%s,%s)\n',nodedata.attr[1],ra,r,g,b,t,mode,ns,master)
        end,
    },
	chargeball = {
        { 'Position', 'any', CheckPos },
		{ 'KeepTime', 'any', CheckExpr},
		{ 'ContractTime', 'any', CheckExpr},
		{ 'Radius', 'any', CheckExpr},
		{ 'Ways', 'any', CheckExpr},
		{ 'Angle', 'any', CheckExpr},
		{ 'R', 'any', CheckExpr},
		{ 'G', 'any', CheckExpr},
		{ 'B', 'any', CheckExpr},
		{ 'RotVelocity', 'any', CheckExpr},
        disptype = 'make chargeball',
        default = { ["type"] = 'chargeball', attr = { 'self.x,self.y','60','80','360','1','300','255','64','64','1.5' } },
        forbidparent = { 'root', 'folder' },
        allowchild = {},
        totext = function(nodedata)
			return string.format("make chargeball in (%s),keep %s frames, contract in %s frames, in radius %s, with %s ways,angle=%s,r=%s,g=%s,b=%s,rotvelocity=%s",nodedata.attr[1],nodedata.attr[2],nodedata.attr[3],nodedata.attr[4],
			nodedata.attr[5],nodedata.attr[6],nodedata.attr[7],nodedata.attr[8],nodedata.attr[9],nodedata.attr[10])
        end,
        tohead = function(nodedata)
		    return string.format("New(boss_cast_darkball,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)\n",nodedata.attr[1],nodedata.attr[2],nodedata.attr[3],nodedata.attr[4],
			nodedata.attr[5],nodedata.attr[6],nodedata.attr[7],nodedata.attr[8],nodedata.attr[9],nodedata.attr[10])
        end,
    },
    explode = {
        { 'Position', 'any', CheckPos },
		{ 'Play Default Sound', 'bool', CheckExpr},
		{ 'Shake Screen', 'bool', CheckExpr},
        disptype = 'boss explode',
        default = { ["type"] = 'explode', attr = { 'self.x,self.y' , 'true' ,'true'} },
        forbidparent = { 'root', 'folder' },
        allowchild = {},
        totext = function(nodedata)
            return 'explode in (' .. nodedata.attr[1] .. ')'
        end,
        tohead = function(nodedata)
            return 'New(boss_death_ef,' .. nodedata.attr[1] ..','.. nodedata.attr[2] ..','.. nodedata.attr[3] ..')\n'
        end,
    },
    --bullet ex
    iteration = {
        { "times", "any", CheckExpr },
        { "interval", "any", CheckExpr },
        { "Emission radius", "any", CheckExpr },
        { "Velocity range", "any", CheckExpr },
        { "Angle Range", "any", CheckExpr },
        { "Acceleration Range", "any", CheckExpr },
        disptype = "Shoot Iteration",
        needancestor = { 'task', 'bossscbefore', 'stagetask', 'dialogtask' },
        allowchild = { "bentlasershooter", "lasershooter", "shooter", "taskwait", "iteration" },
        default = { ["type"] = "iteration", attr = { "3", "0", "0", "0", "0", "0" } },
        tohead = function(nodedata)
            return string.format("new(Iteration, %s, %s, env, function(env)\n",
                    nodedata.attr[1], table.concat(nodedata.attr, ", ", 3, 6))
        end,
        tofoot = function(nodedata)
            return "task._Wait(" .. nodedata.attr[2] .. ")\nend)\n"
        end,
        totext = function(nodedata)
            local ret = string.format("iterate %s times, interval %s frames", nodedata.attr[1], nodedata.attr[2])
            if nodedata.attr[3] ~= "0" then
                ret = ret .. ", radius of " .. nodedata.attr[3]
            end
            if nodedata.attr[4] ~= "0" then
                ret = ret .. ", velocity increase 0 ~ " .. nodedata.attr[4]
            end
            if nodedata.attr[5] ~= "0" then
                ret = ret .. ", angle increase 0 ~ " .. nodedata.attr[5]
            end
            if nodedata.attr[6] ~= "0" then
                ret = ret .. ", acceleration increase 0 ~ " .. nodedata.attr[6]
            end
            return ret
        end
    },
    shooter = {
        { "Style", "bulletstyle", CheckExpr },
        { "Color", "color", CheckExpr },
        { "Position (of center)", "any", CheckPos },
        { "Velocity (of base)", "any", CheckExpr },
        { "Angle (of base)", "any", CheckExpr },
        { "Acceleration (of base)", "any", CheckExpr },
        disptype = "complex bullet",
        forbidparent = { 'root', 'folder' },
        allowchild = { "_node_atp", "_node_g", "_node_accel", "_node_stay", "_node_vf", "_node_pro", "_node_dir",
                       "_node_aa", "_node_moveto", "_node_rot", "_node_pe", "_node_toc", "_node_tof" },
        default = { ["type"] = "shooter", attr = { "arrow_big", "COLOR_RED", "self.x,self.y", "3", "0", "0" } },
        totext = function(nodedata)
            local ret = string.format("shoot a %s %s bullet, at (%s), velocity of %s, angle of %s",
                    nodedata.attr[2], nodedata.attr[1], nodedata.attr[3], nodedata.attr[4], nodedata.attr[5])
            if nodedata.attr[6] ~= "0" then
                ret = ret .. ", acceleration of " .. nodedata.attr[6]
            end
            return ret
        end,
        tohead = function(nodedata)
            return string.format("local parent = self\nlast=New(shooter, %s, env, {\n",
                    table.concat(nodedata.attr, ", "))
        end,
        tofoot = function()
            return "})\n"
        end,
    },
    bentlasershooter = {
        { "Color", "color", CheckExpr },
        { "Position (of center)", "any", CheckPos },
        { "Length", "any", CheckExpr },
        { "Width", "any", CheckExpr },
        { "Velocity (of base)", "any", CheckExpr },
        { "Angle (of base)", "any", CheckExpr },
        { "Acceleration (of base)", "any", CheckExpr },
        disptype = "complex bent laser",
        forbidparent = { 'root', 'folder' },
        allowchild = { "_node_atp", "_node_g", "_node_accel", "_node_stay", "_node_vf", "_node_pro", "_node_dir",
                       "_node_aa", "_node_moveto", "_node_rot", "_node_pe", "_node_toc", "_node_tof" },
        default = { ["type"] = "bentlasershooter", attr = { "COLOR_RED", "self.x,self.y", "32", "8", "3", "0", "0" } },
        totext = function(nodedata)
            local ret = string.format("shoot a %s bent laser, at (%s), velocity of %s, angle of %s",
                    nodedata.attr[1], nodedata.attr[2], nodedata.attr[5], nodedata.attr[6])
            if nodedata.attr[7] ~= "0" then
                ret = ret .. ", acceleration of " .. nodedata.attr[6]
            end
            return ret
        end,
        tohead = function(nodedata)
            return string.format("local parent = self\nlast=New(bent_laser_shooter, %s, env, {\n",
                    table.concat(nodedata.attr, ", "))
        end,
        tofoot = function()
            return "})\n"
        end,
    },
    lasershooter = {
        { "Color", "color", CheckExpr },
        { "Position (of center)", "any", CheckPos },
        { "Length(Head,Body,Tail)", "any", CheckExpr },
        { "Width", "any", CheckExpr },
        { "Node Size", "any", CheckExpr },
        { "Velocity (of base)", "any", CheckExpr },
        { "Angle (of base)", "any", CheckExpr },
        { "Acceleration (of base)", "any", CheckExpr },
        disptype = "complex laser",
        forbidparent = { 'root', 'folder' },
        allowchild = { "_node_atp", "_node_g", "_node_accel", "_node_stay", "_node_vf", "_node_pro", "_node_dir",
                       "_node_aa", "_node_moveto", "_node_rot", "_node_pe", "_node_toc", "_node_tof" },
        default = { ["type"] = "lasershooter", attr = { "COLOR_RED", "self.x,self.y", "8,16,8", "8", "0", "3", "0", "0" } },
        totext = function(nodedata)
            local ret = string.format("shoot a %s laser, at (%s), velocity of %s, angle of %s",
                    nodedata.attr[1], nodedata.attr[2], nodedata.attr[6], nodedata.attr[7])
            if nodedata.attr[8] ~= "0" then
                ret = ret .. ", acceleration of " .. nodedata.attr[6]
            end
            return ret
        end,
        tohead = function(nodedata)
            return string.format("local parent = self\nlast=New(laser_shooter, %s, env, {\n",
                    table.concat(nodedata.attr, ", "))
        end,
        tofoot = function()
            return "})\n"
        end,
    },
    _node_atp = {
        disptype = "aim to player",
        allowparent = { "shooter", "lasershooter", "bentlasershooter" },
        allowchild = {},
        totext = function()
            return "aim to player"
        end,
        tohead = function()
            return "{'aim to player'},\n"
        end,
    },
    _node_g = {
        { "Gravity", "any", CheckExpr },
        { "Max Velocity", "any", CheckExpr },
        { "Max Vertical Velocity", "any", CheckExpr },
        { "Auto Rotation", "bool", CheckExpr },
        disptype = "gravity",
        default = { ["type"] = "_node_g", attr = { "0", "0", "0" } },
        allowparent = { "shooter", "lasershooter", "bentlasershooter" },
        allowchild = {},
        totext = function(nodedata)
            local ret = string.format("gravity of %s", nodedata.attr[1])
            if nodedata.attr[2] then
                ret = ret .. ", maxv of " .. nodedata.attr[2]
            end
            if nodedata.attr[3] then
                ret = ret .. ", maxvy of " .. nodedata.attr[3]
            end
            return ret
        end,
        tohead = function(nodedata)
            return "{'gravity'," .. table.concat(nodedata.attr, ", ") .. "},\n"
        end,
    },
    _node_accel = {
        { "Acceleration", "any", CheckExpr },
        { "Angle", "any", CheckExpr },
        disptype = "acceleration",
        default = { ["type"] = "_node_accel", attr = { "0", "0" } },
        allowparent = { "shooter", "lasershooter", "bentlasershooter" },
        allowchild = {},
        totext = function(nodedata)
            return string.format("acceleration of %s, angle of %s", nodedata.attr[1], nodedata.attr[2])
        end,
        tohead = function(nodedata)
            return "{'acceleration', " .. table.concat(nodedata.attr, ", ") .. "},\n"
        end,
    },
    _node_stay = {
        { "Time", "any", CheckExpr },
        disptype = "go there after a time",
        default = { ["type"] = "_node_stay", attr = { "0" } },
        allowparent = { "shooter", "lasershooter", "bentlasershooter" },
        allowchild = {},
        totext = function(nodedata)
            return string.format("go there after %s frames", nodedata.attr[1])
        end,
        tohead = function(nodedata)
            return "{'stay', " .. nodedata.attr[1] .. "},\n"
        end,
    },
    _node_vf = {
        { "Max Velocity", "any", CheckExpr },
        { "Max Horizonal Velocity", "any", CheckExpr },
        { "Max Vertical Velocity", "any", CheckExpr },
        disptype = "velocity forbid",
        default = { ["type"] = "_node_vf", attr = { "0", "0", "0" } },
        allowparent = { "shooter", "lasershooter", "bentlasershooter" },
        allowchild = {},
        totext = function(nodedata)
            local ret = "forbid velocity"
            if nodedata.attr[1] ~= "0" then
                ret = ret .. " of " .. nodedata.attr[1]
            end
            if nodedata.attr[2] ~= "0" then
                ret = ret .. ", the horizonal of " .. nodedata.attr[2]
            end
            if nodedata.attr[3] ~= "0" then
                ret = ret .. ", the vertical of " .. nodedata.attr[2]
            end
            return ret
        end,
        tohead = function(nodedata)
            return "{'velocity forbid', " .. table.concat(nodedata.attr, ", ") .. "},\n"
        end,
    },
    _node_pro = {
        { "Indestroyable", "bool", CheckExpr },
        { "Auto Rotation", "bool", CheckExpr },
        { "Bound", "bool", CheckExpr },
        { "Rebound", "bool", CheckExpr },
        { "Through", "bool", CheckExpr },
        disptype = "property",
        default = { ["type"] = "_node_pro", attr = { "false", "false", "true", "false", "false" } },
        allowparent = { "shooter", "lasershooter", "bentlasershooter" },
        allowchild = {},
        totext = function(nodedata)
            local ret = "set property"
            if nodedata.attr[1] == "true" then
                ret = ret .. " indestroyable"
            end
            if nodedata.attr[2] == "true" then
                ret = ret .. ", auto rotate"
            end
            if nodedata.attr[3] == "true" then
                ret = ret .. ", release while out of screen"
            end
            if nodedata.attr[4] == "true" then
                ret = ret .. ", rebound while reaching the wall"
            end
            if nodedata.attr[5] == "true" then
                ret = ret .. ", go through while reaching the wall"
            end
            return ret
        end,
        tohead = function(nodedata)
            return "{'property', " .. table.concat(nodedata.attr, ", ") .. "},\n"
        end,
    },
    _node_dir = {
        { "Angular Velocity", "any", CheckExpr },
        { "Connect object", "object", CheckExpr },
        { "Deflection Angle", "any", CheckExpr },
        { "Auto Rotation", "bool", CheckExpr },
        disptype = "direction",
        default = { ["type"] = "_node_dir", attr = { "0", "nil", "0", "false" } },
        allowparent = { "shooter", "lasershooter", "bentlasershooter" },
        allowchild = {},
        totext = function(nodedata)
            local ret = "angular velocity of " .. nodedata.attr[1]
            if nodedata.attr[2] ~= "nil" then
                ret = ret .. ", " .. nodedata.attr[3] .. " deflection connect of " .. nodedata.attr[2]
            end
            if nodedata.attr[4] == "true" then
                ret = ret .. ", auto rotate"
            end
            return ret
        end,
        tohead = function(nodedata)
            return "{'direction', " .. table.concat(nodedata.attr, ", ") .. "},\n"
        end,
    },
    _node_aa = {
        { "Acceleration Addition", "any", CheckExpr },
        { "Angle", "any", CheckExpr },
        disptype = "acceleration addition",
        default = { ["type"] = "_node_aa", attr = { "0", "0" } },
        allowparent = { "shooter", "lasershooter", "bentlasershooter" },
        allowchild = {},
        totext = function(nodedata)
            return string.format("acceleration addition of %s, angle of %s", nodedata.attr[1], nodedata.attr[2])
        end,
        tohead = function(nodedata)
            return "{'jerk', " .. table.concat(nodedata.attr, ", ") .. "},\n"
        end,
    },
    _node_moveto = {
        { "Position", "any", CheckPos },
        { "Time", "any", CheckExpr },
        { "Calculus mode", "calculus", CheckExprOmit },
        { "Move mode", "movetomode", CheckExprOmit },
        disptype = "move to",
        default = { ["type"] = "_node_moveto", attr = { "0,0", "60", "RECTANGULAR", "MOVE_NORMAL" } },
        allowparent = { "shooter", "lasershooter", "bentlasershooter" },
        allowchild = {},
        totext = function(nodedata)
            return string.format("move to (%s: %s), in %s frames, mode of %s", nodedata.attr[3], nodedata.attr[1],
                    nodedata.attr[2], nodedata.attr[4])
        end,
        tohead = function(nodedata)
            return "{'moveto', " .. table.concat(nodedata.attr, ", ") .. "},\n"
        end,
    },
    _node_rot = {
        { "Radius", "any", CheckExpr },
        { "Direct", "direct", CheckExprOmit },
        { "Auto Rotation", "bool", CheckExpr },
        disptype = "rotation",
        default = { ["type"] = "_node_rot", attr = { "120", "anticlockwise", "false" } },
        allowparent = { "shooter", "lasershooter", "bentlasershooter" },
        allowchild = {},
        totext = function(nodedata)
            ret = string.format("%s rotate along the round, radius of %s", nodedata.attr[2], nodedata.attr[1])
            if nodedata.attr[3] == "true" then
                ret = ret .. ", auto rotate"
            end
            return ret
        end,
        tohead = function(nodedata)
            return "{'rotation', " .. table.concat(nodedata.attr, ", ") .. "},\n"
        end,
    },
    _node_pe = {
        { "X calculus", "any", CheckExprOmit },
        { "Y calculus", "any", CheckExprOmit },
        { "Calculus mode", "calculus", CheckExprOmit },
        { "Auto Rotation", "bool", CheckExpr },
        disptype = "parameter equation",
        default = { ["type"] = "_node_pe", attr = { "cos(t)", "sin(t)", "rectangular", "false" } },
        allowparent = { "shooter", "lasershooter", "bentlasershooter" },
        allowchild = {},
        totext = function(nodedata)
            ret = string.format("%s parameter equation, x of (%s), y of (%s)",
                    nodedata.attr[3], nodedata.attr[1], nodedata.attr[2])
            if nodedata.attr[4] == "true" then
                ret = ret .. ", auto rotate"
            end
            return ret
        end,
        tohead = function(nodedata)
            return string.format("{'parameter equation', function(t) return %s end, function(t) return %s end, %s, %s},\n", unpack(nodedata.attr))
        end,
    },
    _node_toc = {
        { "Condition", "any" },
        disptype = "do on condition",
        allowparent = { "shooter", "lasershooter", "bentlasershooter" },
        totext = function(nodedata)
            return "on condition that " .. nodedata.attr[1]
        end,
        tohead = function(nodedata)
            return string.format("{'task on condition', function(self) return %s end, function(self) \n", nodedata.attr[1])
        end,
        tofoot = function()
            return "end},\n"
        end,
    },
    _node_tof = {
        disptype = "do on frame",
        allowparent = { "shooter", "lasershooter", "bentlasershooter" },
        totext = function()
            return "on frame"
        end,
        tohead = function()
            return "{'task on frame', function(self) \n"
        end,
        tofoot = function()
            return "end},\n"
        end,
    },

    --legecy
    setfps = {
        { 'FPS', 'any', CheckExpr },
        disptype = 'Set FPS',
        forbidparent = { 'root', 'folder' },
        allowchild = {},
        default = { ["type"] = 'setfps', attr = { '60' } },
        totext = function(nodedata)
            return "Set FPS of " .. nodedata.attr[1]
        end,
        tohead = function(nodedata)
            return "SetFPS(" .. nodedata.attr[1] .. ")\n"
        end
    },
    highlight = {
        { 'Style', 'bulletstyle', CheckExpr },
        { 'Color', 'color', CheckExpr },
        { 'On/Off', 'bool', CheckExpr },
        default = { ["type"] = 'highlight', attr = { 'arrow_big', 'COLOR_RED', 'true' } },
        forbidparent = { 'root', 'folder' },
        allowchild = {},
        totext = function(nodedata)
            local ret = 'turn '
            if nodedata.attr[3] == 'true' then
                ret = ret .. 'on '
            else
                ret = ret .. 'off '
            end
            return ret .. 'the highlight of ' .. nodedata.attr[1] .. ', color of ' .. nodedata.attr[2]
        end,
        tohead = function(nodedata)
            return string.format("ChangeBulletHighlight(%s)\n", table.concat(nodedata.attr, ","))
        end
    },
    --archi
    archiexpand = {
        { 'Style', 'bulletstyle', CheckExpr },
        { 'Color', 'color', CheckExpr },
        { 'Destroyable', 'bool', CheckExpr },
        { 'Auto Rotation', 'bool', CheckExpr },
        { 'Self Rotation Velocity', 'any', CheckExpr },
        { 'Center', 'any' },
        { 'Start Radius', 'any', CheckExpr },
        { 'Start Angle', 'any', CheckExpr },
        { 'Rotation Velocity', 'any', CheckExpr },
        { 'Radius Increment', 'any', CheckExpr },
        disptype = 'create a bullet flying along the Archimedes spiral',
        forbidparent = { 'root', 'folder' },
        allowchild = {},
        default = { ['type'] = 'archiexpand', ['attr'] = { 'arrow_big', 'COLOR_RED', 'true', 'true', '0', 'self', '0', '0', '0', '0' } },
        totext = function(nodedata)
            return string.format('shoot a %s %s, it flying away from the (%s)', nodedata.attr[2], nodedata.attr[1], nodedata.attr[6])
        end,
        tohead = function(nodedata)
            local center = nodedata.attr[6]
            local _, _, a, b = string.find(center, '^(.*),(.*)$')
            if a then
                center = string.format('{x=(%s),y=(%s)}', a, b)
            end
            return string.format('last=New(archiexpand,%s,%s,%s)\n', table.concat(nodedata.attr, ", ", 1, 5),
                    center, table.concat(nodedata.attr, ", ", 7, 10))
        end
    },
    archirotate = {
        { 'Style', 'bulletstyle', CheckExpr },
        { 'Color', 'color', CheckExpr },
        { 'Destroyable', 'bool', CheckExpr },
        { 'Auto Rotation', 'bool', CheckExpr },
        { 'Self Rotation Velocity', 'any', CheckExpr },
        { 'Center', 'any' },
        { 'Max Radius', 'any', CheckExpr },
        { 'Start Angle', 'any', CheckExpr },
        { 'Rotation Velocity', 'any', CheckExpr },
        { 'Time before rotation', 'any', CheckExpr },
        disptype = 'create a bullet flying along the Archimedes spiral',
        forbidparent = { 'root', 'folder' },
        allowchild = {},
        default = { ['type'] = 'archirotate', ['attr'] = { 'arrow_big', 'COLOR_RED', 'true', 'true', '0', 'self', '0', '0', '0', '0' } },
        totext = function(nodedata)
            return string.format('shoot a %s %s, it flying around the (%s)', nodedata.attr[2], nodedata.attr[1], nodedata.attr[6])
        end,
        tohead = function(nodedata)
            local center = nodedata.attr[6]
            local _, _, a, b = string.find(center, '^(.*),(.*)$')
            if a then
                center = string.format('{x=(%s),y=(%s)}', a, b)
            end
            return string.format('last=New(archirotate,%s,%s,%s)\n', table.concat(nodedata.attr, ", ", 1, 5),
                    center, table.concat(nodedata.attr, ", ", 7, 10))
        end
    },
    --rebounder
    rebounderdefine = {
        { 'Type name', 'typename', CheckClassName },
        disptype = 'define rebounder',
        editfirst = true,
        allowparent = { 'root', 'folder' },
        allowchild = { 'callbackfunc' },
        totext = function(nodedata)
            return string.format("define rebounder type %q", nodedata.attr[1])
        end,
        depth = 0,
        watch = 'rebounder',
        default = {
            ["attr"] = { "" },
            ["type"] = "rebounderdefine",
            ["expand"] = true,
            ["child"] = {
                [1] = {
                    ["attr"] = { "" },
                    ["type"] = "rebounderinit",
                },
            },
        },
        tohead = function(nodedata)
            className = string.match(nodedata.attr[1], '^(.+):.+$') or nodedata.attr[1]
            return string.format("_editor_class[%q]=Class(rebounder)\n", className)
        end,
        tofoot = function()
            return ''
        end,
    },
    rebounderinit = {
        { 'Parameter list', 'any', CheckParam },
        disptype = 'on create rebounder',
        allowparent = {},
        forbiddelete = true,
        totext = function(nodedata)
            return string.format("on create: (%s)", nodedata.attr[1])
        end,
        tohead = function(nodedata)
            local p
            if IsBlank(nodedata.attr[1]) then
                p = "_"
            else
                p = nodedata.attr[1]
            end
            return string.format("_editor_class[%q].init=function(self,_x,_y,_length,_angle,%s)\
	rebounder.init(self,_x,_y,_length,_angle)\
", className, p, nodedata.attr[2], nodedata.attr[3], nodedata.attr[4], nodedata.attr[5])
        end,
        tofoot = function()
            return "end\n"
        end,
    },
    reboundercreate = {
        { 'Type name', 'selecttype', CheckNonBlank },
        { 'Position', 'any', CheckPos },
        { 'Parameter', 'param', CheckExprOmit },
        { 'Length', 'any', CheckExpr },
        { 'Angle', 'any', CheckExpr },
        disptype = 'create rebounder',
        editfirst = true,
        default = { ["type"] = 'reboundercreate', attr = { '', '0,0', '', '128', '0' } },
        forbidparent = { 'root', 'folder' },
        allowchild = {},
        totext = function(nodedata)
            return string.format("create rebounder of type %q at (%s) with parameter %s", nodedata.attr[1], nodedata.attr[2], nodedata.attr[3])
        end,
        tohead = function(nodedata)
            local p
            if IsBlank(nodedata.attr[3]) then
                p = "_"
            else
                p = nodedata.attr[3]
            end
            return string.format("last=New(_editor_class[%q],%s,%s,%s,%s)\n", nodedata.fullclassname,
                    nodedata.attr[2], nodedata.attr[4], nodedata.attr[5], p)
        end,
        check = function(nodedata)
            local class
            if watchDict.rebounder[nodedata.attr[1]] then
                class = nodedata.attr[1]
            else
                return string.format('rebounder type %q does not exist', nodedata.attr[1])
            end
            if paramNumDict[class] ~= CalcParamNum(nodedata.attr[3]) then
                return "number of parameter is incorrect"
            end
            nodedata.fullclassname = class
        end,
    },
    simplerebounder = {
        { "Position", "any", CheckPos },
        { "Length", 'any', CheckExpr },
        { "Angle", "any", CheckExpr },
        disptype = "create a simple rebounder",
        default = { ["type"] = "simplerebounder", attr = { "0,0", "128", "0" } },
        forbidparent = { "root", "folder" },
        allowchild = {},
        totext = function(nodedata)
            return string.format("create a simple rebounder at (%s), length of %s, angle of %s",
                    nodedata.attr[1], nodedata.attr[2], nodedata.attr[3])
        end,
        tohead = function(nodedata)
            return string.format("last=New(rebounder, %s)\n", table.concat(nodedata.attr, ", "))
        end
    },
}
enumType = {
    any = {},
    resfile = {},
    bool = { 'false', 'true' },
    ['for'] = { 'i', 'j', 'k', 'l', 'm', 'n' },
    movetomode = { 'MOVE_NORMAL', 'MOVE_ACCEL', 'MOVE_DECEL', 'MOVE_ACC_DEC' },
    directmode = { "MOVE_X_TOWARDS_PLAYER", "MOVE_Y_TOWARDS_PLAYER", "MOVE_TOWARDS_PLAYER", "MOVE_RANDOM" },
    bulletstyle = { 'arrow_big', 'arrow_mid', 'arrow_small', 'gun_bullet', 'butterfly', 'square', 'ball_small', 'ball_mid',
                    'ball_mid_c', 'ball_big', 'ball_huge', 'ball_light', 'star_small', 'star_big', 'grain_a',
                    'grain_b', 'grain_c', 'kite', 'knife', 'knife_b', 'water_drop', 'mildew', 'ellipse', 'heart', 'money',
                    'music', 'silence',
                    'water_drop_dark', 'ball_huge_dark', 'ball_light_dark' },
    bulletshow = { 'scale', 'arrow', 'chain', 'bullet', 'butterfly', 'ofuda', 'point', 'smallball',
                   'circle', 'middleball', 'bigball', 'lightball', 'smallstar', 'bigstar', 'grain',
                   'needle', 'blackgrain', 'drip', 'sword', 'knife', 'fire', 'mildew', 'ellipse', 'heart', 'money',
                   'music', 'silence',
                   'fire_dark', 'bigball_dark', 'lightball_dark' },
    color = { 'COLOR_RED', 'COLOR_DEEP_RED', 'COLOR_PURPLE', 'COLOR_DEEP_PURPLE', 'COLOR_BLUE', 'COLOR_DEEP_BLUE',
              'COLOR_ROYAL_BLUE', 'COLOR_CYAN', 'COLOR_DEEP_GREEN', 'COLOR_GREEN', 'COLOR_CHARTREUSE', 'COLOR_YELLOW',
              'COLOR_GOLDEN_YELLOW', 'COLOR_ORANGE', 'COLOR_DEEP_GRAY', 'COLOR_GRAY' },
    object = { "player", "_boss", "self", "nil" },
    calculus = { "RECTANGULAR", "POLAR" },
    direct = { "clockwise", "anticlockwise" },
    sound = {},
    image = {},
    selecttype = {},
    param = {},
    typename = {},
    difficulty = { '1', '2', '3', '4', '5' },
    stagegroup = { 'Easy', 'Normal', 'Hard', 'Lunatic', 'Extra' },
    selectenemystyle = {},
    event = { 'frame', 'render', 'colli', 'kill', 'del' },
    leftright = { 'left', 'right' },
    item = { 'item_power', 'item_faith', 'item_point', 'item_power_large', 'item_power_full', 'item_faith_minor',
             'item_extend', 'item_chip', 'item_bomb', 'item_bombchip' },
    target = { 'self', 'last', 'unit', 'player', '_boss' },
    timeunit = { 'UNIT_SECOND', 'UNIT_FRAME', 'UNIT_MUSIC' },
    properties = {
        "x",
        "y",
        "rot",
        "omiga",
        "timer",
        "vx",
        "vy",
        "ax",
        "ay",
        "layer",
        "group",
        "hide",
        "bound",
        "navi",
        "colli",
        "status",
        "hscale",
        "vscale",
        "a",
        "b",
        "rect",
        "img",
        "pause",
        "rmove",
        "nopause",
        "_angle",
        "_speed",
    },
    propertiesval = {
        "x",
        "y",
        "rot",
        "omiga",
        "vx",
        "vy",
        "ax",
        "ay",
        "hscale",
        "vscale",
        "a",
        "b",
        "pause",
        "_angle",
        "_speed",
    },
    layer = {
        'LAYER_BG',
        'LAYER_BG+1',
        'LAYER_BG-1',
        'LAYER_ENEMY',
        'LAYER_ENEMY+1',
        'LAYER_ENEMY-1',
        'LAYER_PLAYER_BULLET',
        'LAYER_PLAYER_BULLET+1',
        'LAYER_PLAYER_BULLET-1',
        'LAYER_PLAYER',
        'LAYER_PLAYER+1',
        'LAYER_PLAYER-1',
        'LAYER_ITEM',
        'LAYER_ITEM+1',
        'LAYER_ITEM-1',
        'LAYER_ENEMY_BULLET',
        'LAYER_ENEMY_BULLET+1',
        'LAYER_ENEMY_BULLET-1',
        'LAYER_ENEMY_BULLET_EF',
        'LAYER_ENEMY_BULLET_EF+1',
        'LAYER_ENEMY_BULLET_EF-1',
        'LAYER_TOP',
        'LAYER_TOP+1',
        'LAYER_TOP-1',
    },
    group = {
        'GROUP_GHOST',
        'GROUP_ENEMY_BULLET',
        'GROUP_ENEMY',
        'GROUP_PLAYER_BULLET',
        'GROUP_PLAYER',
        'GROUP_INDES',
        'GROUP_ITEM',
        'GROUP_NONTJT',
    },
    bgstage = { 'temple', 'magic_forest', 'bamboo', 'bamboo2', 'cube', 'gensokyosora',
                'hongmoguanB', 'icepool', 'lake', 'le03_5', 'magic_forest_fast',
                'river', 'starlight', 'temple2', 'woods', 'world',
                '', },
    blend = { '', 'mul+add', 'mul+alpha', 'add+add', 'add+alpha', 'mul+sub', 'mul+rev', 'add+sub', 'add+rev', 'alpha+bal', },
    projectmode = { '', 'game', 'lib' },
    valuemode = {
        'MODE_SET',
        'MODE_ADD',
        'MODE_MUL'
    }
}
for k, v in pairs(nodeType) do
    v.name = k
    if not v.disptype then
        v.disptype = k
    end
    if v.allowchild then
        for _, typename in ipairs(v.allowchild) do
            v.allowchild[typename] = true
        end
    end
    if v.forbidchild then
        for _, typename in ipairs(v.forbidchild) do
            v.forbidchild[typename] = true
        end
    end
    if v.allowparent then
        for _, typename in ipairs(v.allowparent) do
            v.allowparent[typename] = true
        end
    end
    if v.forbidparent then
        for _, typename in ipairs(v.forbidparent) do
            v.forbidparent[typename] = true
        end
    end
    if v.needancestor then
        for _, typename in ipairs(v.needancestor) do
            v.needancestor[typename] = true
        end
    end
    if v.forbidancestor then
        for _, typename in ipairs(v.forbidancestor) do
            v.forbidancestor[typename] = true
        end
    end
    if v.watch then
        Tree.watch[v.watch] = {}
    end
end
